// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.10
// 	protoc        (unknown)
// source: xai/api/v1/chat.proto

package v1

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type MessageRole int32

const (
	// Default value / invalid role.
	MessageRole_INVALID_ROLE MessageRole = 0
	// User role.
	MessageRole_ROLE_USER MessageRole = 1
	// Assistant role, normally the response from the model.
	MessageRole_ROLE_ASSISTANT MessageRole = 2
	// System role, typically for system instructions.
	MessageRole_ROLE_SYSTEM MessageRole = 3
	// Indicates a return from a tool call. Deprecated in favor of ROLE_TOOL.
	//
	// Deprecated: Marked as deprecated in xai/api/v1/chat.proto.
	MessageRole_ROLE_FUNCTION MessageRole = 4
	// Indicates a return from a tool call.
	MessageRole_ROLE_TOOL MessageRole = 5
)

// Enum value maps for MessageRole.
var (
	MessageRole_name = map[int32]string{
		0: "INVALID_ROLE",
		1: "ROLE_USER",
		2: "ROLE_ASSISTANT",
		3: "ROLE_SYSTEM",
		4: "ROLE_FUNCTION",
		5: "ROLE_TOOL",
	}
	MessageRole_value = map[string]int32{
		"INVALID_ROLE":   0,
		"ROLE_USER":      1,
		"ROLE_ASSISTANT": 2,
		"ROLE_SYSTEM":    3,
		"ROLE_FUNCTION":  4,
		"ROLE_TOOL":      5,
	}
)

func (x MessageRole) Enum() *MessageRole {
	p := new(MessageRole)
	*p = x
	return p
}

func (x MessageRole) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MessageRole) Descriptor() protoreflect.EnumDescriptor {
	return file_xai_api_v1_chat_proto_enumTypes[0].Descriptor()
}

func (MessageRole) Type() protoreflect.EnumType {
	return &file_xai_api_v1_chat_proto_enumTypes[0]
}

func (x MessageRole) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MessageRole.Descriptor instead.
func (MessageRole) EnumDescriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{0}
}

type ReasoningEffort int32

const (
	ReasoningEffort_INVALID_EFFORT ReasoningEffort = 0
	ReasoningEffort_EFFORT_LOW     ReasoningEffort = 1
	ReasoningEffort_EFFORT_MEDIUM  ReasoningEffort = 2
	ReasoningEffort_EFFORT_HIGH    ReasoningEffort = 3
)

// Enum value maps for ReasoningEffort.
var (
	ReasoningEffort_name = map[int32]string{
		0: "INVALID_EFFORT",
		1: "EFFORT_LOW",
		2: "EFFORT_MEDIUM",
		3: "EFFORT_HIGH",
	}
	ReasoningEffort_value = map[string]int32{
		"INVALID_EFFORT": 0,
		"EFFORT_LOW":     1,
		"EFFORT_MEDIUM":  2,
		"EFFORT_HIGH":    3,
	}
)

func (x ReasoningEffort) Enum() *ReasoningEffort {
	p := new(ReasoningEffort)
	*p = x
	return p
}

func (x ReasoningEffort) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ReasoningEffort) Descriptor() protoreflect.EnumDescriptor {
	return file_xai_api_v1_chat_proto_enumTypes[1].Descriptor()
}

func (ReasoningEffort) Type() protoreflect.EnumType {
	return &file_xai_api_v1_chat_proto_enumTypes[1]
}

func (x ReasoningEffort) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ReasoningEffort.Descriptor instead.
func (ReasoningEffort) EnumDescriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{1}
}

type ToolMode int32

const (
	// Invalid tool mode.
	ToolMode_TOOL_MODE_INVALID ToolMode = 0
	// Let the model decide if a tool shall be used.
	ToolMode_TOOL_MODE_AUTO ToolMode = 1
	// Force the model to not use tools.
	ToolMode_TOOL_MODE_NONE ToolMode = 2
	// Force the model to use tools.
	ToolMode_TOOL_MODE_REQUIRED ToolMode = 3
)

// Enum value maps for ToolMode.
var (
	ToolMode_name = map[int32]string{
		0: "TOOL_MODE_INVALID",
		1: "TOOL_MODE_AUTO",
		2: "TOOL_MODE_NONE",
		3: "TOOL_MODE_REQUIRED",
	}
	ToolMode_value = map[string]int32{
		"TOOL_MODE_INVALID":  0,
		"TOOL_MODE_AUTO":     1,
		"TOOL_MODE_NONE":     2,
		"TOOL_MODE_REQUIRED": 3,
	}
)

func (x ToolMode) Enum() *ToolMode {
	p := new(ToolMode)
	*p = x
	return p
}

func (x ToolMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ToolMode) Descriptor() protoreflect.EnumDescriptor {
	return file_xai_api_v1_chat_proto_enumTypes[2].Descriptor()
}

func (ToolMode) Type() protoreflect.EnumType {
	return &file_xai_api_v1_chat_proto_enumTypes[2]
}

func (x ToolMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ToolMode.Descriptor instead.
func (ToolMode) EnumDescriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{2}
}

type FormatType int32

const (
	// Invalid format type.
	FormatType_FORMAT_TYPE_INVALID FormatType = 0
	// Raw text.
	FormatType_FORMAT_TYPE_TEXT FormatType = 1
	// Any JSON object.
	FormatType_FORMAT_TYPE_JSON_OBJECT FormatType = 2
	// Follow a JSON schema.
	FormatType_FORMAT_TYPE_JSON_SCHEMA FormatType = 3
)

// Enum value maps for FormatType.
var (
	FormatType_name = map[int32]string{
		0: "FORMAT_TYPE_INVALID",
		1: "FORMAT_TYPE_TEXT",
		2: "FORMAT_TYPE_JSON_OBJECT",
		3: "FORMAT_TYPE_JSON_SCHEMA",
	}
	FormatType_value = map[string]int32{
		"FORMAT_TYPE_INVALID":     0,
		"FORMAT_TYPE_TEXT":        1,
		"FORMAT_TYPE_JSON_OBJECT": 2,
		"FORMAT_TYPE_JSON_SCHEMA": 3,
	}
)

func (x FormatType) Enum() *FormatType {
	p := new(FormatType)
	*p = x
	return p
}

func (x FormatType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FormatType) Descriptor() protoreflect.EnumDescriptor {
	return file_xai_api_v1_chat_proto_enumTypes[3].Descriptor()
}

func (FormatType) Type() protoreflect.EnumType {
	return &file_xai_api_v1_chat_proto_enumTypes[3]
}

func (x FormatType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FormatType.Descriptor instead.
func (FormatType) EnumDescriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{3}
}

type ToolCallType int32

const (
	ToolCallType_TOOL_CALL_TYPE_INVALID ToolCallType = 0
	// Indicates the tool is a client-side tool, and should be executed on client side.
	// Maps to `function_call` type in OAI Responses API.
	ToolCallType_TOOL_CALL_TYPE_CLIENT_SIDE_TOOL ToolCallType = 1
	// Indicates the tool is a server-side web_search tool, and client side won't need to execute.
	// Maps to `web_search_call` type in OAI Responses API.
	ToolCallType_TOOL_CALL_TYPE_WEB_SEARCH_TOOL ToolCallType = 2
	// Indicates the tool is a server-side x_search tool, and client side won't need to execute.
	// Maps to `x_search_call` type in OAI Responses API.
	ToolCallType_TOOL_CALL_TYPE_X_SEARCH_TOOL ToolCallType = 3
	// Indicates the tool is a server-side code_execution tool, and client side won't need to execute.
	// Maps to `code_interpreter_call` type in OAI Responses API.
	ToolCallType_TOOL_CALL_TYPE_CODE_EXECUTION_TOOL ToolCallType = 4
	// Indicates the tool is a server-side collections_search tool, and client side won't need to execute.
	// Maps to `file_search_call` type in OAI Responses API.
	ToolCallType_TOOL_CALL_TYPE_COLLECTIONS_SEARCH_TOOL ToolCallType = 5
	// Indicates the tool is a server-side mcp_tool, and client side won't need to execute.
	// Maps to `mcp_call` type in OAI Responses API.
	ToolCallType_TOOL_CALL_TYPE_MCP_TOOL ToolCallType = 6
	// Indicates the tool is a server-side document_search tool, and client side won't need to execute.
	ToolCallType_TOOL_CALL_TYPE_DOCUMENT_SEARCH_TOOL ToolCallType = 7
)

// Enum value maps for ToolCallType.
var (
	ToolCallType_name = map[int32]string{
		0: "TOOL_CALL_TYPE_INVALID",
		1: "TOOL_CALL_TYPE_CLIENT_SIDE_TOOL",
		2: "TOOL_CALL_TYPE_WEB_SEARCH_TOOL",
		3: "TOOL_CALL_TYPE_X_SEARCH_TOOL",
		4: "TOOL_CALL_TYPE_CODE_EXECUTION_TOOL",
		5: "TOOL_CALL_TYPE_COLLECTIONS_SEARCH_TOOL",
		6: "TOOL_CALL_TYPE_MCP_TOOL",
		7: "TOOL_CALL_TYPE_DOCUMENT_SEARCH_TOOL",
	}
	ToolCallType_value = map[string]int32{
		"TOOL_CALL_TYPE_INVALID":                 0,
		"TOOL_CALL_TYPE_CLIENT_SIDE_TOOL":        1,
		"TOOL_CALL_TYPE_WEB_SEARCH_TOOL":         2,
		"TOOL_CALL_TYPE_X_SEARCH_TOOL":           3,
		"TOOL_CALL_TYPE_CODE_EXECUTION_TOOL":     4,
		"TOOL_CALL_TYPE_COLLECTIONS_SEARCH_TOOL": 5,
		"TOOL_CALL_TYPE_MCP_TOOL":                6,
		"TOOL_CALL_TYPE_DOCUMENT_SEARCH_TOOL":    7,
	}
)

func (x ToolCallType) Enum() *ToolCallType {
	p := new(ToolCallType)
	*p = x
	return p
}

func (x ToolCallType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ToolCallType) Descriptor() protoreflect.EnumDescriptor {
	return file_xai_api_v1_chat_proto_enumTypes[4].Descriptor()
}

func (ToolCallType) Type() protoreflect.EnumType {
	return &file_xai_api_v1_chat_proto_enumTypes[4]
}

func (x ToolCallType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ToolCallType.Descriptor instead.
func (ToolCallType) EnumDescriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{4}
}

type ToolCallStatus int32

const (
	// The tool call is in progress.
	ToolCallStatus_TOOL_CALL_STATUS_IN_PROGRESS ToolCallStatus = 0
	// The tool call is completed.
	ToolCallStatus_TOOL_CALL_STATUS_COMPLETED ToolCallStatus = 1
	// The tool call is incomplete.
	ToolCallStatus_TOOL_CALL_STATUS_INCOMPLETE ToolCallStatus = 2
	// The tool call is failed.
	ToolCallStatus_TOOL_CALL_STATUS_FAILED ToolCallStatus = 3
)

// Enum value maps for ToolCallStatus.
var (
	ToolCallStatus_name = map[int32]string{
		0: "TOOL_CALL_STATUS_IN_PROGRESS",
		1: "TOOL_CALL_STATUS_COMPLETED",
		2: "TOOL_CALL_STATUS_INCOMPLETE",
		3: "TOOL_CALL_STATUS_FAILED",
	}
	ToolCallStatus_value = map[string]int32{
		"TOOL_CALL_STATUS_IN_PROGRESS": 0,
		"TOOL_CALL_STATUS_COMPLETED":   1,
		"TOOL_CALL_STATUS_INCOMPLETE":  2,
		"TOOL_CALL_STATUS_FAILED":      3,
	}
)

func (x ToolCallStatus) Enum() *ToolCallStatus {
	p := new(ToolCallStatus)
	*p = x
	return p
}

func (x ToolCallStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ToolCallStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_xai_api_v1_chat_proto_enumTypes[5].Descriptor()
}

func (ToolCallStatus) Type() protoreflect.EnumType {
	return &file_xai_api_v1_chat_proto_enumTypes[5]
}

func (x ToolCallStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ToolCallStatus.Descriptor instead.
func (ToolCallStatus) EnumDescriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{5}
}

// Mode to control the web search.
type SearchMode int32

const (
	SearchMode_INVALID_SEARCH_MODE SearchMode = 0
	SearchMode_OFF_SEARCH_MODE     SearchMode = 1
	SearchMode_ON_SEARCH_MODE      SearchMode = 2
	SearchMode_AUTO_SEARCH_MODE    SearchMode = 3
)

// Enum value maps for SearchMode.
var (
	SearchMode_name = map[int32]string{
		0: "INVALID_SEARCH_MODE",
		1: "OFF_SEARCH_MODE",
		2: "ON_SEARCH_MODE",
		3: "AUTO_SEARCH_MODE",
	}
	SearchMode_value = map[string]int32{
		"INVALID_SEARCH_MODE": 0,
		"OFF_SEARCH_MODE":     1,
		"ON_SEARCH_MODE":      2,
		"AUTO_SEARCH_MODE":    3,
	}
)

func (x SearchMode) Enum() *SearchMode {
	p := new(SearchMode)
	*p = x
	return p
}

func (x SearchMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (SearchMode) Descriptor() protoreflect.EnumDescriptor {
	return file_xai_api_v1_chat_proto_enumTypes[6].Descriptor()
}

func (SearchMode) Type() protoreflect.EnumType {
	return &file_xai_api_v1_chat_proto_enumTypes[6]
}

func (x SearchMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use SearchMode.Descriptor instead.
func (SearchMode) EnumDescriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{6}
}

type GetCompletionsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A sequence of messages in the conversation. There must be at least a single
	// message that the model can respond to.
	Messages []*Message `protobuf:"bytes,1,rep,name=messages,proto3" json:"messages,omitempty"`
	// Name of the model. This is the name as reported by the models API. More
	// details can be found on your console at https://console.x.ai.
	Model string `protobuf:"bytes,2,opt,name=model,proto3" json:"model,omitempty"`
	// An opaque string supplied by the API client (customer) to identify a user.
	// The string will be stored in the logs and can be used in customer service
	// requests to identify certain requests.
	User string `protobuf:"bytes,16,opt,name=user,proto3" json:"user,omitempty"`
	// The number of completions to create concurrently. A single completion will
	// be generated if the parameter is unset. Each completion is charged at the
	// same rate. You can generate at most 128 concurrent completions.
	// PLEASE NOTE: This field is deprecated and will be removed in the future.
	N *int32 `protobuf:"varint,8,opt,name=n,proto3,oneof" json:"n,omitempty"`
	// The maximum number of tokens to sample. If unset, the model samples until
	// one of the following stop-conditions is reached:
	// - The context length of the model is exceeded
	// - One of the `stop` sequences has been observed.
	// - The time limit exceeds.
	//
	// Note that for reasoning models and models that support function calls, the
	// limit is only applied to the main content and not to the reasoning content
	// or function calls.
	//
	// We recommend choosing a reasonable value to reduce the risk of accidental
	// long-generations that consume many tokens.
	MaxTokens *int32 `protobuf:"varint,7,opt,name=max_tokens,json=maxTokens,proto3,oneof" json:"max_tokens,omitempty"`
	// A random seed used to make the sampling process deterministic. This is
	// provided in a best-effort basis without guarantee that sampling is 100%
	// deterministic given a seed. This is primarily provided for short-lived
	// testing purposes. Given a fixed request and seed, the answers may change
	// over time as our systems evolve.
	Seed *int32 `protobuf:"varint,11,opt,name=seed,proto3,oneof" json:"seed,omitempty"`
	// String patterns that will cause the sampling procedure to stop prematurely
	// when observed.
	// Note that the completion is based on individual tokens and sampling can
	// only terminate at token boundaries. If a stop string is a substring of an
	// individual token, the completion will include the entire token, which
	// extends beyond the stop string.
	// For example, if `stop = ["wor"]` and we prompt the model with "hello" to
	// which it responds with "world", then the sampling procedure will stop after
	// observing the "world" token and the completion will contain
	// the entire world "world" even though the stop string was just "wor".
	// You can provide at most 8 stop strings.
	Stop []string `protobuf:"bytes,12,rep,name=stop,proto3" json:"stop,omitempty"`
	// A number between 0 and 2 used to control the variance of completions.
	// The smaller the value, the more deterministic the model will become. For
	// example, if we sample 1000 answers to the same prompt at a temperature of
	// 0.001, then most of the 1000 answers will be identical. Conversely, if we
	// conduct the same experiment at a temperature of 2, virtually no two answers
	// will be identical. Note that increasing the temperature will cause
	// the model to hallucinate more strongly.
	Temperature *float32 `protobuf:"fixed32,14,opt,name=temperature,proto3,oneof" json:"temperature,omitempty"`
	// A number between 0 and 1 controlling the likelihood of the model to use
	// less-common answers. Recall that the model produces a probability for
	// each token. This means, for any choice of token there are thousands of
	// possibilities to choose from. This parameter controls the "nucleus sampling
	// algorithm". Instead of considering every possible token at every step, we
	// only look at the K tokens who's probabilities exceed `top_p`.
	// For example, if we set `top_p = 0.9`, then the set of tokens we actually
	// sample from, will have a probability mass of at least 90%. In practice,
	// low values will make the model more deterministic.
	TopP *float32 `protobuf:"fixed32,15,opt,name=top_p,json=topP,proto3,oneof" json:"top_p,omitempty"`
	// If set to true, log probabilities of the sampling are returned.
	Logprobs bool `protobuf:"varint,5,opt,name=logprobs,proto3" json:"logprobs,omitempty"`
	// Number of top log probabilities to return.
	TopLogprobs *int32 `protobuf:"varint,6,opt,name=top_logprobs,json=topLogprobs,proto3,oneof" json:"top_logprobs,omitempty"`
	// A list of tools the model may call. Currently, only functions are supported
	// as a tool. Use this to provide a list of functions the model may generate
	// JSON inputs for.
	Tools []*Tool `protobuf:"bytes,17,rep,name=tools,proto3" json:"tools,omitempty"`
	// Controls if the model can, should, or must not use tools.
	ToolChoice *ToolChoice `protobuf:"bytes,18,opt,name=tool_choice,json=toolChoice,proto3" json:"tool_choice,omitempty"`
	// Formatting constraint on the response.
	ResponseFormat *ResponseFormat `protobuf:"bytes,10,opt,name=response_format,json=responseFormat,proto3" json:"response_format,omitempty"`
	// Positive values penalize new tokens based on their existing frequency in
	// the text so far, decreasing the model's likelihood to repeat the same line
	// verbatim.
	FrequencyPenalty *float32 `protobuf:"fixed32,3,opt,name=frequency_penalty,json=frequencyPenalty,proto3,oneof" json:"frequency_penalty,omitempty"`
	// Positive values penalize new tokens based on whether they appear in
	// the text so far, increasing the model's likelihood to talk about
	// new topics.
	PresencePenalty *float32 `protobuf:"fixed32,9,opt,name=presence_penalty,json=presencePenalty,proto3,oneof" json:"presence_penalty,omitempty"`
	// Constrains effort on reasoning for reasoning models. Default to `EFFORT_MEDIUM`.
	ReasoningEffort *ReasoningEffort `protobuf:"varint,19,opt,name=reasoning_effort,json=reasoningEffort,proto3,enum=xai_api.ReasoningEffort,oneof" json:"reasoning_effort,omitempty"`
	// Set the parameters to be used for realtime data. If not set, no realtime data will be acquired by the model.
	SearchParameters *SearchParameters `protobuf:"bytes,20,opt,name=search_parameters,json=searchParameters,proto3,oneof" json:"search_parameters,omitempty"`
	// / If set to false, the model can perform maximum one tool call per response. Default to true.
	ParallelToolCalls *bool `protobuf:"varint,21,opt,name=parallel_tool_calls,json=parallelToolCalls,proto3,oneof" json:"parallel_tool_calls,omitempty"`
	// Previous response id. The messages from this response must be chained.
	PreviousResponseId *string `protobuf:"bytes,22,opt,name=previous_response_id,json=previousResponseId,proto3,oneof" json:"previous_response_id,omitempty"`
	// Whether to store request and responses. Default is false.
	StoreMessages bool `protobuf:"varint,23,opt,name=store_messages,json=storeMessages,proto3" json:"store_messages,omitempty"`
	// Whether to use encrypted thinking for thinking trace rehydration.
	UseEncryptedContent bool `protobuf:"varint,24,opt,name=use_encrypted_content,json=useEncryptedContent,proto3" json:"use_encrypted_content,omitempty"`
	// Maximum number of agentic tool calling turns allowed for this request.
	// If not set, defaults to the server's global cap.
	// The effective max_turns will be the min of the server's global cap and the request's max_turns.
	// This parameter will be ignored for any non-agentic requests.
	// With parallel tool calls, multiple tool calls can occur within a single turn,
	// so max_turns does not necessarily equal the total number of tool calls.
	MaxTurns      *int32 `protobuf:"varint,25,opt,name=max_turns,json=maxTurns,proto3,oneof" json:"max_turns,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetCompletionsRequest) Reset() {
	*x = GetCompletionsRequest{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetCompletionsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetCompletionsRequest) ProtoMessage() {}

func (x *GetCompletionsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetCompletionsRequest.ProtoReflect.Descriptor instead.
func (*GetCompletionsRequest) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{0}
}

func (x *GetCompletionsRequest) GetMessages() []*Message {
	if x != nil {
		return x.Messages
	}
	return nil
}

func (x *GetCompletionsRequest) GetModel() string {
	if x != nil {
		return x.Model
	}
	return ""
}

func (x *GetCompletionsRequest) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *GetCompletionsRequest) GetN() int32 {
	if x != nil && x.N != nil {
		return *x.N
	}
	return 0
}

func (x *GetCompletionsRequest) GetMaxTokens() int32 {
	if x != nil && x.MaxTokens != nil {
		return *x.MaxTokens
	}
	return 0
}

func (x *GetCompletionsRequest) GetSeed() int32 {
	if x != nil && x.Seed != nil {
		return *x.Seed
	}
	return 0
}

func (x *GetCompletionsRequest) GetStop() []string {
	if x != nil {
		return x.Stop
	}
	return nil
}

func (x *GetCompletionsRequest) GetTemperature() float32 {
	if x != nil && x.Temperature != nil {
		return *x.Temperature
	}
	return 0
}

func (x *GetCompletionsRequest) GetTopP() float32 {
	if x != nil && x.TopP != nil {
		return *x.TopP
	}
	return 0
}

func (x *GetCompletionsRequest) GetLogprobs() bool {
	if x != nil {
		return x.Logprobs
	}
	return false
}

func (x *GetCompletionsRequest) GetTopLogprobs() int32 {
	if x != nil && x.TopLogprobs != nil {
		return *x.TopLogprobs
	}
	return 0
}

func (x *GetCompletionsRequest) GetTools() []*Tool {
	if x != nil {
		return x.Tools
	}
	return nil
}

func (x *GetCompletionsRequest) GetToolChoice() *ToolChoice {
	if x != nil {
		return x.ToolChoice
	}
	return nil
}

func (x *GetCompletionsRequest) GetResponseFormat() *ResponseFormat {
	if x != nil {
		return x.ResponseFormat
	}
	return nil
}

func (x *GetCompletionsRequest) GetFrequencyPenalty() float32 {
	if x != nil && x.FrequencyPenalty != nil {
		return *x.FrequencyPenalty
	}
	return 0
}

func (x *GetCompletionsRequest) GetPresencePenalty() float32 {
	if x != nil && x.PresencePenalty != nil {
		return *x.PresencePenalty
	}
	return 0
}

func (x *GetCompletionsRequest) GetReasoningEffort() ReasoningEffort {
	if x != nil && x.ReasoningEffort != nil {
		return *x.ReasoningEffort
	}
	return ReasoningEffort_INVALID_EFFORT
}

func (x *GetCompletionsRequest) GetSearchParameters() *SearchParameters {
	if x != nil {
		return x.SearchParameters
	}
	return nil
}

func (x *GetCompletionsRequest) GetParallelToolCalls() bool {
	if x != nil && x.ParallelToolCalls != nil {
		return *x.ParallelToolCalls
	}
	return false
}

func (x *GetCompletionsRequest) GetPreviousResponseId() string {
	if x != nil && x.PreviousResponseId != nil {
		return *x.PreviousResponseId
	}
	return ""
}

func (x *GetCompletionsRequest) GetStoreMessages() bool {
	if x != nil {
		return x.StoreMessages
	}
	return false
}

func (x *GetCompletionsRequest) GetUseEncryptedContent() bool {
	if x != nil {
		return x.UseEncryptedContent
	}
	return false
}

func (x *GetCompletionsRequest) GetMaxTurns() int32 {
	if x != nil && x.MaxTurns != nil {
		return *x.MaxTurns
	}
	return 0
}

type GetChatCompletionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of this request. This ID will also show up on your billing records
	// and you can use it when contacting us regarding a specific request.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Model-generated outputs/responses to the input messages. Each output contains
	// the model's response including text content, reasoning traces, tool calls, and
	// metadata about the generation process.
	Outputs []*CompletionOutput `protobuf:"bytes,2,rep,name=outputs,proto3" json:"outputs,omitempty"`
	// A UNIX timestamp (UTC) indicating when the response object was created.
	// The timestamp is taken when the model starts generating response.
	Created *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=created,proto3" json:"created,omitempty"`
	// The name of the model used for the request. This model name contains
	// the actual model name used rather than any aliases.
	// This means the this can be `grok-2-1212` even when the request was
	// specifying `grok-2-latest`.
	Model string `protobuf:"bytes,6,opt,name=model,proto3" json:"model,omitempty"`
	// This fingerprint represents the backend configuration that the model runs
	// with.
	SystemFingerprint string `protobuf:"bytes,7,opt,name=system_fingerprint,json=systemFingerprint,proto3" json:"system_fingerprint,omitempty"`
	// The number of tokens consumed by this request.
	Usage *SamplingUsage `protobuf:"bytes,9,opt,name=usage,proto3" json:"usage,omitempty"`
	// / List of all the external pages (urls) used by the model to produce its final answer.
	// This is only present when live search is enabled, (That is `SearchParameters` have been defined in `GetCompletionsRequest`).
	Citations []string `protobuf:"bytes,10,rep,name=citations,proto3" json:"citations,omitempty"`
	// Settings used while generating the response.
	Settings *RequestSettings `protobuf:"bytes,11,opt,name=settings,proto3" json:"settings,omitempty"`
	// Debug output. Only available to trusted testers.
	DebugOutput   *DebugOutput `protobuf:"bytes,12,opt,name=debug_output,json=debugOutput,proto3" json:"debug_output,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetChatCompletionResponse) Reset() {
	*x = GetChatCompletionResponse{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetChatCompletionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetChatCompletionResponse) ProtoMessage() {}

func (x *GetChatCompletionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetChatCompletionResponse.ProtoReflect.Descriptor instead.
func (*GetChatCompletionResponse) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{1}
}

func (x *GetChatCompletionResponse) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *GetChatCompletionResponse) GetOutputs() []*CompletionOutput {
	if x != nil {
		return x.Outputs
	}
	return nil
}

func (x *GetChatCompletionResponse) GetCreated() *timestamppb.Timestamp {
	if x != nil {
		return x.Created
	}
	return nil
}

func (x *GetChatCompletionResponse) GetModel() string {
	if x != nil {
		return x.Model
	}
	return ""
}

func (x *GetChatCompletionResponse) GetSystemFingerprint() string {
	if x != nil {
		return x.SystemFingerprint
	}
	return ""
}

func (x *GetChatCompletionResponse) GetUsage() *SamplingUsage {
	if x != nil {
		return x.Usage
	}
	return nil
}

func (x *GetChatCompletionResponse) GetCitations() []string {
	if x != nil {
		return x.Citations
	}
	return nil
}

func (x *GetChatCompletionResponse) GetSettings() *RequestSettings {
	if x != nil {
		return x.Settings
	}
	return nil
}

func (x *GetChatCompletionResponse) GetDebugOutput() *DebugOutput {
	if x != nil {
		return x.DebugOutput
	}
	return nil
}

type GetChatCompletionChunk struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of this request. This ID will also show up on your billing records
	// and you can use it when contacting us regarding a specific request.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Model-generated outputs/responses being streamed as they are generated.
	// Each output chunk contains incremental updates to the model's response.
	Outputs []*CompletionOutputChunk `protobuf:"bytes,2,rep,name=outputs,proto3" json:"outputs,omitempty"`
	// A UNIX timestamp (UTC) indicating when the response object was created.
	// The timestamp is taken when the model starts generating response.
	Created *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=created,proto3" json:"created,omitempty"`
	// The name of the model used for the request. This model name contains
	// the actual model name used rather than any aliases.
	// This means the this can be `grok-2-1212` even when the request was
	// specifying `grok-2-latest`.
	Model string `protobuf:"bytes,4,opt,name=model,proto3" json:"model,omitempty"`
	// This fingerprint represents the backend configuration that the model runs
	// with.
	SystemFingerprint string `protobuf:"bytes,5,opt,name=system_fingerprint,json=systemFingerprint,proto3" json:"system_fingerprint,omitempty"`
	// The total number of tokens consumed when this chunk was streamed. Note that
	// this is not the final number of tokens billed unless this is the last chunk
	// in the stream.
	Usage *SamplingUsage `protobuf:"bytes,6,opt,name=usage,proto3" json:"usage,omitempty"`
	// / List of all the external pages used by the model to answer. Only populated for the last chunk.
	// This is only present for requests that make use of live search or server-side search tools.
	Citations []string `protobuf:"bytes,7,rep,name=citations,proto3" json:"citations,omitempty"`
	// Only available for teams that have debugging privileges.
	DebugOutput   *DebugOutput `protobuf:"bytes,10,opt,name=debug_output,json=debugOutput,proto3" json:"debug_output,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetChatCompletionChunk) Reset() {
	*x = GetChatCompletionChunk{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetChatCompletionChunk) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetChatCompletionChunk) ProtoMessage() {}

func (x *GetChatCompletionChunk) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetChatCompletionChunk.ProtoReflect.Descriptor instead.
func (*GetChatCompletionChunk) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{2}
}

func (x *GetChatCompletionChunk) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *GetChatCompletionChunk) GetOutputs() []*CompletionOutputChunk {
	if x != nil {
		return x.Outputs
	}
	return nil
}

func (x *GetChatCompletionChunk) GetCreated() *timestamppb.Timestamp {
	if x != nil {
		return x.Created
	}
	return nil
}

func (x *GetChatCompletionChunk) GetModel() string {
	if x != nil {
		return x.Model
	}
	return ""
}

func (x *GetChatCompletionChunk) GetSystemFingerprint() string {
	if x != nil {
		return x.SystemFingerprint
	}
	return ""
}

func (x *GetChatCompletionChunk) GetUsage() *SamplingUsage {
	if x != nil {
		return x.Usage
	}
	return nil
}

func (x *GetChatCompletionChunk) GetCitations() []string {
	if x != nil {
		return x.Citations
	}
	return nil
}

func (x *GetChatCompletionChunk) GetDebugOutput() *DebugOutput {
	if x != nil {
		return x.DebugOutput
	}
	return nil
}

// Response from GetDeferredCompletion, including the response if the completion
// request has been processed without error.
type GetDeferredCompletionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Current status of the request.
	Status DeferredStatus `protobuf:"varint,2,opt,name=status,proto3,enum=xai_api.DeferredStatus" json:"status,omitempty"`
	// Response. Only present if `status=DONE`
	Response      *GetChatCompletionResponse `protobuf:"bytes,1,opt,name=response,proto3,oneof" json:"response,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetDeferredCompletionResponse) Reset() {
	*x = GetDeferredCompletionResponse{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetDeferredCompletionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetDeferredCompletionResponse) ProtoMessage() {}

func (x *GetDeferredCompletionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetDeferredCompletionResponse.ProtoReflect.Descriptor instead.
func (*GetDeferredCompletionResponse) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{3}
}

func (x *GetDeferredCompletionResponse) GetStatus() DeferredStatus {
	if x != nil {
		return x.Status
	}
	return DeferredStatus_INVALID_DEFERRED_STATUS
}

func (x *GetDeferredCompletionResponse) GetResponse() *GetChatCompletionResponse {
	if x != nil {
		return x.Response
	}
	return nil
}

// Contains the response generated by the model.
type CompletionOutput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Indicating why the model stopped sampling.
	FinishReason FinishReason `protobuf:"varint,1,opt,name=finish_reason,json=finishReason,proto3,enum=xai_api.FinishReason" json:"finish_reason,omitempty"`
	// The index of this output in the list of outputs. When multiple outputs are
	// generated, each output is assigned a sequential index starting from 0.
	Index int32 `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	// The actual message generated by the model.
	Message *CompletionMessage `protobuf:"bytes,3,opt,name=message,proto3" json:"message,omitempty"`
	// The log probabilities of the sampling.
	Logprobs      *LogProbs `protobuf:"bytes,4,opt,name=logprobs,proto3" json:"logprobs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompletionOutput) Reset() {
	*x = CompletionOutput{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompletionOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompletionOutput) ProtoMessage() {}

func (x *CompletionOutput) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompletionOutput.ProtoReflect.Descriptor instead.
func (*CompletionOutput) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{4}
}

func (x *CompletionOutput) GetFinishReason() FinishReason {
	if x != nil {
		return x.FinishReason
	}
	return FinishReason_REASON_INVALID
}

func (x *CompletionOutput) GetIndex() int32 {
	if x != nil {
		return x.Index
	}
	return 0
}

func (x *CompletionOutput) GetMessage() *CompletionMessage {
	if x != nil {
		return x.Message
	}
	return nil
}

func (x *CompletionOutput) GetLogprobs() *LogProbs {
	if x != nil {
		return x.Logprobs
	}
	return nil
}

// Holds the model output (i.e. the result of the sampling process).
type CompletionMessage struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The generated text based on the input prompt.
	Content string `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	// Reasoning trace the model produced before issuing the final answer.
	ReasoningContent string `protobuf:"bytes,4,opt,name=reasoning_content,json=reasoningContent,proto3" json:"reasoning_content,omitempty"`
	// The role of the message author. Will always default to "assistant".
	Role MessageRole `protobuf:"varint,2,opt,name=role,proto3,enum=xai_api.MessageRole" json:"role,omitempty"`
	// The tools that the assistant wants to call.
	ToolCalls []*ToolCall `protobuf:"bytes,3,rep,name=tool_calls,json=toolCalls,proto3" json:"tool_calls,omitempty"`
	// The encrypted content.
	EncryptedContent string `protobuf:"bytes,5,opt,name=encrypted_content,json=encryptedContent,proto3" json:"encrypted_content,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *CompletionMessage) Reset() {
	*x = CompletionMessage{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompletionMessage) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompletionMessage) ProtoMessage() {}

func (x *CompletionMessage) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompletionMessage.ProtoReflect.Descriptor instead.
func (*CompletionMessage) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{5}
}

func (x *CompletionMessage) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *CompletionMessage) GetReasoningContent() string {
	if x != nil {
		return x.ReasoningContent
	}
	return ""
}

func (x *CompletionMessage) GetRole() MessageRole {
	if x != nil {
		return x.Role
	}
	return MessageRole_INVALID_ROLE
}

func (x *CompletionMessage) GetToolCalls() []*ToolCall {
	if x != nil {
		return x.ToolCalls
	}
	return nil
}

func (x *CompletionMessage) GetEncryptedContent() string {
	if x != nil {
		return x.EncryptedContent
	}
	return ""
}

// Holds the differences (deltas) that when concatenated make up the entire
// agent response.
type CompletionOutputChunk struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The actual text differences that need to be accumulated on the client.
	Delta *Delta `protobuf:"bytes,1,opt,name=delta,proto3" json:"delta,omitempty"`
	// The log probability of the choice.
	Logprobs *LogProbs `protobuf:"bytes,2,opt,name=logprobs,proto3" json:"logprobs,omitempty"`
	// Indicating why the model stopped sampling.
	FinishReason FinishReason `protobuf:"varint,3,opt,name=finish_reason,json=finishReason,proto3,enum=xai_api.FinishReason" json:"finish_reason,omitempty"`
	// The index of this output chunk in the list of output chunks.
	Index         int32 `protobuf:"varint,4,opt,name=index,proto3" json:"index,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CompletionOutputChunk) Reset() {
	*x = CompletionOutputChunk{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CompletionOutputChunk) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CompletionOutputChunk) ProtoMessage() {}

func (x *CompletionOutputChunk) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CompletionOutputChunk.ProtoReflect.Descriptor instead.
func (*CompletionOutputChunk) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{6}
}

func (x *CompletionOutputChunk) GetDelta() *Delta {
	if x != nil {
		return x.Delta
	}
	return nil
}

func (x *CompletionOutputChunk) GetLogprobs() *LogProbs {
	if x != nil {
		return x.Logprobs
	}
	return nil
}

func (x *CompletionOutputChunk) GetFinishReason() FinishReason {
	if x != nil {
		return x.FinishReason
	}
	return FinishReason_REASON_INVALID
}

func (x *CompletionOutputChunk) GetIndex() int32 {
	if x != nil {
		return x.Index
	}
	return 0
}

// The delta of a streaming response.
type Delta struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The main model output/answer.
	Content string `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	// Part of the model's reasoning trace.
	ReasoningContent string `protobuf:"bytes,4,opt,name=reasoning_content,json=reasoningContent,proto3" json:"reasoning_content,omitempty"`
	// The entity type who sent the message. For example, a message can be sent by
	// a user or the assistant.
	Role MessageRole `protobuf:"varint,2,opt,name=role,proto3,enum=xai_api.MessageRole" json:"role,omitempty"`
	// A list of tool calls if tool call is requested by the model.
	ToolCalls []*ToolCall `protobuf:"bytes,3,rep,name=tool_calls,json=toolCalls,proto3" json:"tool_calls,omitempty"`
	// The encrypted content.
	EncryptedContent string `protobuf:"bytes,5,opt,name=encrypted_content,json=encryptedContent,proto3" json:"encrypted_content,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *Delta) Reset() {
	*x = Delta{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Delta) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Delta) ProtoMessage() {}

func (x *Delta) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Delta.ProtoReflect.Descriptor instead.
func (*Delta) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{7}
}

func (x *Delta) GetContent() string {
	if x != nil {
		return x.Content
	}
	return ""
}

func (x *Delta) GetReasoningContent() string {
	if x != nil {
		return x.ReasoningContent
	}
	return ""
}

func (x *Delta) GetRole() MessageRole {
	if x != nil {
		return x.Role
	}
	return MessageRole_INVALID_ROLE
}

func (x *Delta) GetToolCalls() []*ToolCall {
	if x != nil {
		return x.ToolCalls
	}
	return nil
}

func (x *Delta) GetEncryptedContent() string {
	if x != nil {
		return x.EncryptedContent
	}
	return ""
}

// Holding the log probabilities of the sampling.
type LogProbs struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A list of log probability entries, each corresponding to a sampled token
	// and its associated data.
	Content       []*LogProb `protobuf:"bytes,1,rep,name=content,proto3" json:"content,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogProbs) Reset() {
	*x = LogProbs{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogProbs) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogProbs) ProtoMessage() {}

func (x *LogProbs) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogProbs.ProtoReflect.Descriptor instead.
func (*LogProbs) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{8}
}

func (x *LogProbs) GetContent() []*LogProb {
	if x != nil {
		return x.Content
	}
	return nil
}

// Represents the logarithmic probability and metadata for a single sampled
// token.
type LogProb struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The text representation of the sampled token.
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	// The logarithmic probability of this token being sampled, given the prior
	// context.
	Logprob float32 `protobuf:"fixed32,2,opt,name=logprob,proto3" json:"logprob,omitempty"`
	// The raw byte representation of the token, useful for handling non-text or
	// encoded data.
	Bytes []byte `protobuf:"bytes,3,opt,name=bytes,proto3" json:"bytes,omitempty"`
	// A list of the top alternative tokens and their log probabilities at this
	// sampling step.
	TopLogprobs   []*TopLogProb `protobuf:"bytes,4,rep,name=top_logprobs,json=topLogprobs,proto3" json:"top_logprobs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LogProb) Reset() {
	*x = LogProb{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogProb) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogProb) ProtoMessage() {}

func (x *LogProb) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogProb.ProtoReflect.Descriptor instead.
func (*LogProb) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{9}
}

func (x *LogProb) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

func (x *LogProb) GetLogprob() float32 {
	if x != nil {
		return x.Logprob
	}
	return 0
}

func (x *LogProb) GetBytes() []byte {
	if x != nil {
		return x.Bytes
	}
	return nil
}

func (x *LogProb) GetTopLogprobs() []*TopLogProb {
	if x != nil {
		return x.TopLogprobs
	}
	return nil
}

// Represents an alternative token and its log probability among the top
// candidates.
type TopLogProb struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The text representation of an alternative token considered by the model.
	Token string `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	// The logarithmic probability of this alternative token being sampled.
	Logprob float32 `protobuf:"fixed32,2,opt,name=logprob,proto3" json:"logprob,omitempty"`
	// The raw byte representation of the alternative token.
	Bytes         []byte `protobuf:"bytes,3,opt,name=bytes,proto3" json:"bytes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *TopLogProb) Reset() {
	*x = TopLogProb{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *TopLogProb) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*TopLogProb) ProtoMessage() {}

func (x *TopLogProb) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use TopLogProb.ProtoReflect.Descriptor instead.
func (*TopLogProb) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{10}
}

func (x *TopLogProb) GetToken() string {
	if x != nil {
		return x.Token
	}
	return ""
}

func (x *TopLogProb) GetLogprob() float32 {
	if x != nil {
		return x.Logprob
	}
	return 0
}

func (x *TopLogProb) GetBytes() []byte {
	if x != nil {
		return x.Bytes
	}
	return nil
}

// Holds a single content element that is part of an input message.
type Content struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Content:
	//
	//	*Content_Text
	//	*Content_ImageUrl
	//	*Content_File
	Content       isContent_Content `protobuf_oneof:"content"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Content) Reset() {
	*x = Content{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Content) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Content) ProtoMessage() {}

func (x *Content) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Content.ProtoReflect.Descriptor instead.
func (*Content) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{11}
}

func (x *Content) GetContent() isContent_Content {
	if x != nil {
		return x.Content
	}
	return nil
}

func (x *Content) GetText() string {
	if x != nil {
		if x, ok := x.Content.(*Content_Text); ok {
			return x.Text
		}
	}
	return ""
}

func (x *Content) GetImageUrl() *ImageUrlContent {
	if x != nil {
		if x, ok := x.Content.(*Content_ImageUrl); ok {
			return x.ImageUrl
		}
	}
	return nil
}

func (x *Content) GetFile() *FileContent {
	if x != nil {
		if x, ok := x.Content.(*Content_File); ok {
			return x.File
		}
	}
	return nil
}

type isContent_Content interface {
	isContent_Content()
}

type Content_Text struct {
	// The content is a pure text message.
	Text string `protobuf:"bytes,1,opt,name=text,proto3,oneof"`
}

type Content_ImageUrl struct {
	// The content is a single image.
	ImageUrl *ImageUrlContent `protobuf:"bytes,2,opt,name=image_url,json=imageUrl,proto3,oneof"`
}

type Content_File struct {
	// The content is a file attachment (PDF, document, etc.).
	File *FileContent `protobuf:"bytes,3,opt,name=file,proto3,oneof"`
}

func (*Content_Text) isContent_Content() {}

func (*Content_ImageUrl) isContent_Content() {}

func (*Content_File) isContent_Content() {}

// A file attachment in a message.
type FileContent struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The file ID returned by the Files API when a user uploads a file.
	// This ID is used to reference the uploaded file in chat conversations.
	FileId        string `protobuf:"bytes,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FileContent) Reset() {
	*x = FileContent{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FileContent) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FileContent) ProtoMessage() {}

func (x *FileContent) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FileContent.ProtoReflect.Descriptor instead.
func (*FileContent) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{12}
}

func (x *FileContent) GetFileId() string {
	if x != nil {
		return x.FileId
	}
	return ""
}

// A message in a conversation. This message is part of the model input. Each
// message originates from a "role", which indicates the entity type who sent
// the message. Messages can contain multiple content elements such as text and
// images.
type Message struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The content of the message. Some model support multi-modal message contents
	// that consist of text and images. At least one content element must be set
	// for each message.
	Content []*Content `protobuf:"bytes,1,rep,name=content,proto3" json:"content,omitempty"`
	// Reasoning trace the model produced before issuing the final answer.
	ReasoningContent *string `protobuf:"bytes,5,opt,name=reasoning_content,json=reasoningContent,proto3,oneof" json:"reasoning_content,omitempty"`
	// The entity type who sent the message. For example, a message can be sent by
	// a user or the assistant.
	Role MessageRole `protobuf:"varint,2,opt,name=role,proto3,enum=xai_api.MessageRole" json:"role,omitempty"`
	// The name of the entity who sent the message. The name can only be set if
	// the role is ROLE_USER.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The tools that the assistant wants to call.
	ToolCalls []*ToolCall `protobuf:"bytes,4,rep,name=tool_calls,json=toolCalls,proto3" json:"tool_calls,omitempty"`
	// The encrypted content.
	EncryptedContent string `protobuf:"bytes,6,opt,name=encrypted_content,json=encryptedContent,proto3" json:"encrypted_content,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *Message) Reset() {
	*x = Message{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Message) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Message) ProtoMessage() {}

func (x *Message) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Message.ProtoReflect.Descriptor instead.
func (*Message) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{13}
}

func (x *Message) GetContent() []*Content {
	if x != nil {
		return x.Content
	}
	return nil
}

func (x *Message) GetReasoningContent() string {
	if x != nil && x.ReasoningContent != nil {
		return *x.ReasoningContent
	}
	return ""
}

func (x *Message) GetRole() MessageRole {
	if x != nil {
		return x.Role
	}
	return MessageRole_INVALID_ROLE
}

func (x *Message) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Message) GetToolCalls() []*ToolCall {
	if x != nil {
		return x.ToolCalls
	}
	return nil
}

func (x *Message) GetEncryptedContent() string {
	if x != nil {
		return x.EncryptedContent
	}
	return ""
}

type ToolChoice struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to ToolChoice:
	//
	//	*ToolChoice_Mode
	//	*ToolChoice_FunctionName
	ToolChoice    isToolChoice_ToolChoice `protobuf_oneof:"tool_choice"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ToolChoice) Reset() {
	*x = ToolChoice{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ToolChoice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToolChoice) ProtoMessage() {}

func (x *ToolChoice) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToolChoice.ProtoReflect.Descriptor instead.
func (*ToolChoice) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{14}
}

func (x *ToolChoice) GetToolChoice() isToolChoice_ToolChoice {
	if x != nil {
		return x.ToolChoice
	}
	return nil
}

func (x *ToolChoice) GetMode() ToolMode {
	if x != nil {
		if x, ok := x.ToolChoice.(*ToolChoice_Mode); ok {
			return x.Mode
		}
	}
	return ToolMode_TOOL_MODE_INVALID
}

func (x *ToolChoice) GetFunctionName() string {
	if x != nil {
		if x, ok := x.ToolChoice.(*ToolChoice_FunctionName); ok {
			return x.FunctionName
		}
	}
	return ""
}

type isToolChoice_ToolChoice interface {
	isToolChoice_ToolChoice()
}

type ToolChoice_Mode struct {
	// Force the model to perform in a given mode.
	Mode ToolMode `protobuf:"varint,1,opt,name=mode,proto3,enum=xai_api.ToolMode,oneof"`
}

type ToolChoice_FunctionName struct {
	// Force the model to call a particular function.
	FunctionName string `protobuf:"bytes,2,opt,name=function_name,json=functionName,proto3,oneof"`
}

func (*ToolChoice_Mode) isToolChoice_ToolChoice() {}

func (*ToolChoice_FunctionName) isToolChoice_ToolChoice() {}

type Tool struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Tool:
	//
	//	*Tool_Function
	//	*Tool_WebSearch
	//	*Tool_XSearch
	//	*Tool_CodeExecution
	//	*Tool_CollectionsSearch
	//	*Tool_Mcp
	//	*Tool_DocumentSearch
	Tool          isTool_Tool `protobuf_oneof:"tool"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Tool) Reset() {
	*x = Tool{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Tool) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Tool) ProtoMessage() {}

func (x *Tool) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Tool.ProtoReflect.Descriptor instead.
func (*Tool) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{15}
}

func (x *Tool) GetTool() isTool_Tool {
	if x != nil {
		return x.Tool
	}
	return nil
}

func (x *Tool) GetFunction() *Function {
	if x != nil {
		if x, ok := x.Tool.(*Tool_Function); ok {
			return x.Function
		}
	}
	return nil
}

func (x *Tool) GetWebSearch() *WebSearch {
	if x != nil {
		if x, ok := x.Tool.(*Tool_WebSearch); ok {
			return x.WebSearch
		}
	}
	return nil
}

func (x *Tool) GetXSearch() *XSearch {
	if x != nil {
		if x, ok := x.Tool.(*Tool_XSearch); ok {
			return x.XSearch
		}
	}
	return nil
}

func (x *Tool) GetCodeExecution() *CodeExecution {
	if x != nil {
		if x, ok := x.Tool.(*Tool_CodeExecution); ok {
			return x.CodeExecution
		}
	}
	return nil
}

func (x *Tool) GetCollectionsSearch() *CollectionsSearch {
	if x != nil {
		if x, ok := x.Tool.(*Tool_CollectionsSearch); ok {
			return x.CollectionsSearch
		}
	}
	return nil
}

func (x *Tool) GetMcp() *MCP {
	if x != nil {
		if x, ok := x.Tool.(*Tool_Mcp); ok {
			return x.Mcp
		}
	}
	return nil
}

func (x *Tool) GetDocumentSearch() *DocumentSearch {
	if x != nil {
		if x, ok := x.Tool.(*Tool_DocumentSearch); ok {
			return x.DocumentSearch
		}
	}
	return nil
}

type isTool_Tool interface {
	isTool_Tool()
}

type Tool_Function struct {
	// Tool Call defined by user
	Function *Function `protobuf:"bytes,1,opt,name=function,proto3,oneof"`
}

type Tool_WebSearch struct {
	// Built in web search.
	WebSearch *WebSearch `protobuf:"bytes,3,opt,name=web_search,json=webSearch,proto3,oneof"`
}

type Tool_XSearch struct {
	// Built in X search.
	XSearch *XSearch `protobuf:"bytes,4,opt,name=x_search,json=xSearch,proto3,oneof"`
}

type Tool_CodeExecution struct {
	// Built in code execution.
	CodeExecution *CodeExecution `protobuf:"bytes,5,opt,name=code_execution,json=codeExecution,proto3,oneof"`
}

type Tool_CollectionsSearch struct {
	// Built in collections search.
	CollectionsSearch *CollectionsSearch `protobuf:"bytes,6,opt,name=collections_search,json=collectionsSearch,proto3,oneof"`
}

type Tool_Mcp struct {
	// A remote MCP server to use.
	Mcp *MCP `protobuf:"bytes,7,opt,name=mcp,proto3,oneof"`
}

type Tool_DocumentSearch struct {
	// Built in document search.
	DocumentSearch *DocumentSearch `protobuf:"bytes,8,opt,name=document_search,json=documentSearch,proto3,oneof"`
}

func (*Tool_Function) isTool_Tool() {}

func (*Tool_WebSearch) isTool_Tool() {}

func (*Tool_XSearch) isTool_Tool() {}

func (*Tool_CodeExecution) isTool_Tool() {}

func (*Tool_CollectionsSearch) isTool_Tool() {}

func (*Tool_Mcp) isTool_Tool() {}

func (*Tool_DocumentSearch) isTool_Tool() {}

type MCP struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// A label for the server. if provided, this will be used to prefix tool calls.
	ServerLabel string `protobuf:"bytes,1,opt,name=server_label,json=serverLabel,proto3" json:"server_label,omitempty"`
	// A description of the server.
	ServerDescription string `protobuf:"bytes,2,opt,name=server_description,json=serverDescription,proto3" json:"server_description,omitempty"`
	// The URL of the MCP server.
	ServerUrl string `protobuf:"bytes,3,opt,name=server_url,json=serverUrl,proto3" json:"server_url,omitempty"`
	// A list of tool names that are allowed to be called by the model. If empty, all tools are allowed.
	AllowedToolNames []string `protobuf:"bytes,4,rep,name=allowed_tool_names,json=allowedToolNames,proto3" json:"allowed_tool_names,omitempty"`
	// An optional authorization token to use when calling the MCP server. This will be set as the Authorization header.
	Authorization *string `protobuf:"bytes,5,opt,name=authorization,proto3,oneof" json:"authorization,omitempty"`
	// Extra headers that will be included in the request to the MCP server.
	ExtraHeaders  map[string]string `protobuf:"bytes,6,rep,name=extra_headers,json=extraHeaders,proto3" json:"extra_headers,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MCP) Reset() {
	*x = MCP{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MCP) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MCP) ProtoMessage() {}

func (x *MCP) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MCP.ProtoReflect.Descriptor instead.
func (*MCP) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{16}
}

func (x *MCP) GetServerLabel() string {
	if x != nil {
		return x.ServerLabel
	}
	return ""
}

func (x *MCP) GetServerDescription() string {
	if x != nil {
		return x.ServerDescription
	}
	return ""
}

func (x *MCP) GetServerUrl() string {
	if x != nil {
		return x.ServerUrl
	}
	return ""
}

func (x *MCP) GetAllowedToolNames() []string {
	if x != nil {
		return x.AllowedToolNames
	}
	return nil
}

func (x *MCP) GetAuthorization() string {
	if x != nil && x.Authorization != nil {
		return *x.Authorization
	}
	return ""
}

func (x *MCP) GetExtraHeaders() map[string]string {
	if x != nil {
		return x.ExtraHeaders
	}
	return nil
}

type WebSearch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of website domains (without protocol specification or subdomains) to exclude from search results (e.g., ["example.com"]).
	// Use this to prevent results from unwanted sites. A maximum of 5 websites can be excluded.
	// This parameter cannot be set together with `allowed_domains`.
	ExcludedDomains []string `protobuf:"bytes,1,rep,name=excluded_domains,json=excludedDomains,proto3" json:"excluded_domains,omitempty"`
	// List of website domains (without protocol specification or subdomains)
	// to restrict search results to (e.g., ["example.com"]). A maximum of 5 websites can be allowed.
	// Use this as a whitelist to limit results to only these specific sites; no other websites will
	// be considered. If no relevant information is found on these websites, the number of results
	// returned might be smaller than `max_search_results` set in `SearchParameters`. Note: This
	// parameter cannot be set together with `excluded_domains`.
	AllowedDomains []string `protobuf:"bytes,2,rep,name=allowed_domains,json=allowedDomains,proto3" json:"allowed_domains,omitempty"`
	// Enable image understanding in downstream tools (e.g. allow fetching and interpreting images).
	// When true, the server may add image viewing tools to the active MCP toolset.
	EnableImageUnderstanding *bool `protobuf:"varint,3,opt,name=enable_image_understanding,json=enableImageUnderstanding,proto3,oneof" json:"enable_image_understanding,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *WebSearch) Reset() {
	*x = WebSearch{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WebSearch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WebSearch) ProtoMessage() {}

func (x *WebSearch) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WebSearch.ProtoReflect.Descriptor instead.
func (*WebSearch) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{17}
}

func (x *WebSearch) GetExcludedDomains() []string {
	if x != nil {
		return x.ExcludedDomains
	}
	return nil
}

func (x *WebSearch) GetAllowedDomains() []string {
	if x != nil {
		return x.AllowedDomains
	}
	return nil
}

func (x *WebSearch) GetEnableImageUnderstanding() bool {
	if x != nil && x.EnableImageUnderstanding != nil {
		return *x.EnableImageUnderstanding
	}
	return false
}

type XSearch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional start date for search results in ISO-8601 YYYY-MM-DD format (e.g., "2024-05-24").
	// Only content after this date will be considered. Defaults to unset (no start date restriction).
	// See https://en.wikipedia.org/wiki/ISO_8601 for format details.
	FromDate *timestamppb.Timestamp `protobuf:"bytes,1,opt,name=from_date,json=fromDate,proto3,oneof" json:"from_date,omitempty"`
	// Optional end date for search results in ISO-8601 YYYY-MM-DD format (e.g., "2024-12-24").
	// Only content before this date will be considered. Defaults to unset (no end date restriction).
	// See https://en.wikipedia.org/wiki/ISO_8601 for format details.
	ToDate *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=to_date,json=toDate,proto3,oneof" json:"to_date,omitempty"`
	// Optional list of X usernames (without the '@' symbol) to limit search results to posts
	// from specific accounts (e.g., ["xai"]). If set, only posts authored by these
	// handles will be considered in the agentic search.
	// This field can not be set together with `excluded_x_handles`.
	// Defaults to unset (no exclusions).
	AllowedXHandles []string `protobuf:"bytes,3,rep,name=allowed_x_handles,json=allowedXHandles,proto3" json:"allowed_x_handles,omitempty"`
	// Optional list of X usernames (without the '@' symbol) used to exclude posts from specific accounts.
	// If set, posts authored by these handles will be excluded from the agentic search results.
	// This field can not be set together with `allowed_x_handles`.
	// Defaults to unset (no exclusions).
	ExcludedXHandles []string `protobuf:"bytes,4,rep,name=excluded_x_handles,json=excludedXHandles,proto3" json:"excluded_x_handles,omitempty"`
	// Enable image understanding in downstream tools (e.g. allow fetching and interpreting images).
	// When true, the server may add image viewing tools to the active MCP toolset.
	EnableImageUnderstanding *bool `protobuf:"varint,5,opt,name=enable_image_understanding,json=enableImageUnderstanding,proto3,oneof" json:"enable_image_understanding,omitempty"`
	// Enable video understanding in downstream tools (e.g. allow fetching and interpreting videos).
	// When true, the server may add video viewing tools to the active MCP toolset.
	EnableVideoUnderstanding *bool `protobuf:"varint,6,opt,name=enable_video_understanding,json=enableVideoUnderstanding,proto3,oneof" json:"enable_video_understanding,omitempty"`
	unknownFields            protoimpl.UnknownFields
	sizeCache                protoimpl.SizeCache
}

func (x *XSearch) Reset() {
	*x = XSearch{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *XSearch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*XSearch) ProtoMessage() {}

func (x *XSearch) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use XSearch.ProtoReflect.Descriptor instead.
func (*XSearch) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{18}
}

func (x *XSearch) GetFromDate() *timestamppb.Timestamp {
	if x != nil {
		return x.FromDate
	}
	return nil
}

func (x *XSearch) GetToDate() *timestamppb.Timestamp {
	if x != nil {
		return x.ToDate
	}
	return nil
}

func (x *XSearch) GetAllowedXHandles() []string {
	if x != nil {
		return x.AllowedXHandles
	}
	return nil
}

func (x *XSearch) GetExcludedXHandles() []string {
	if x != nil {
		return x.ExcludedXHandles
	}
	return nil
}

func (x *XSearch) GetEnableImageUnderstanding() bool {
	if x != nil && x.EnableImageUnderstanding != nil {
		return *x.EnableImageUnderstanding
	}
	return false
}

func (x *XSearch) GetEnableVideoUnderstanding() bool {
	if x != nil && x.EnableVideoUnderstanding != nil {
		return *x.EnableVideoUnderstanding
	}
	return false
}

type CodeExecution struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CodeExecution) Reset() {
	*x = CodeExecution{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CodeExecution) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CodeExecution) ProtoMessage() {}

func (x *CodeExecution) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CodeExecution.ProtoReflect.Descriptor instead.
func (*CodeExecution) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{19}
}

type CollectionsSearch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID(s) of the source collection(s) within which the search should be performed.
	// A maximum of 10 collections IDs can be used for search.
	CollectionIds []string `protobuf:"bytes,1,rep,name=collection_ids,json=collectionIds,proto3" json:"collection_ids,omitempty"`
	// Optional number of chunks to be returned for each collections search.
	// Defaults to 10.
	Limit         *int32 `protobuf:"varint,2,opt,name=limit,proto3,oneof" json:"limit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CollectionsSearch) Reset() {
	*x = CollectionsSearch{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CollectionsSearch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CollectionsSearch) ProtoMessage() {}

func (x *CollectionsSearch) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CollectionsSearch.ProtoReflect.Descriptor instead.
func (*CollectionsSearch) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{20}
}

func (x *CollectionsSearch) GetCollectionIds() []string {
	if x != nil {
		return x.CollectionIds
	}
	return nil
}

func (x *CollectionsSearch) GetLimit() int32 {
	if x != nil && x.Limit != nil {
		return *x.Limit
	}
	return 0
}

type DocumentSearch struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional number of files to limit the search to.
	Limit         *int32 `protobuf:"varint,2,opt,name=limit,proto3,oneof" json:"limit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DocumentSearch) Reset() {
	*x = DocumentSearch{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DocumentSearch) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DocumentSearch) ProtoMessage() {}

func (x *DocumentSearch) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DocumentSearch.ProtoReflect.Descriptor instead.
func (*DocumentSearch) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{21}
}

func (x *DocumentSearch) GetLimit() int32 {
	if x != nil && x.Limit != nil {
		return *x.Limit
	}
	return 0
}

type Function struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the function.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Description of the function.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Not supported: Only kept for compatibility reasons.
	Strict bool `protobuf:"varint,3,opt,name=strict,proto3" json:"strict,omitempty"`
	// The parameters the functions accepts, described as a JSON Schema object.
	Parameters    string `protobuf:"bytes,4,opt,name=parameters,proto3" json:"parameters,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Function) Reset() {
	*x = Function{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Function) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Function) ProtoMessage() {}

func (x *Function) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Function.ProtoReflect.Descriptor instead.
func (*Function) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{22}
}

func (x *Function) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Function) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Function) GetStrict() bool {
	if x != nil {
		return x.Strict
	}
	return false
}

func (x *Function) GetParameters() string {
	if x != nil {
		return x.Parameters
	}
	return ""
}

// Content of a tool call, typically in a response from model.
type ToolCall struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The ID of the tool call.
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Information to indicate whether the tool call needs to be executed on client side or server side.
	// By default, it will be a client-side tool call if not specified.
	Type ToolCallType `protobuf:"varint,2,opt,name=type,proto3,enum=xai_api.ToolCallType" json:"type,omitempty"`
	// Status of the tool call.
	Status ToolCallStatus `protobuf:"varint,3,opt,name=status,proto3,enum=xai_api.ToolCallStatus" json:"status,omitempty"`
	// Error message if the tool call is failed.
	ErrorMessage *string `protobuf:"bytes,4,opt,name=error_message,json=errorMessage,proto3,oneof" json:"error_message,omitempty"`
	// Information regarding invoking the tool call.
	//
	// Types that are valid to be assigned to Tool:
	//
	//	*ToolCall_Function
	Tool          isToolCall_Tool `protobuf_oneof:"tool"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ToolCall) Reset() {
	*x = ToolCall{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ToolCall) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ToolCall) ProtoMessage() {}

func (x *ToolCall) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ToolCall.ProtoReflect.Descriptor instead.
func (*ToolCall) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{23}
}

func (x *ToolCall) GetId() string {
	if x != nil {
		return x.Id
	}
	return ""
}

func (x *ToolCall) GetType() ToolCallType {
	if x != nil {
		return x.Type
	}
	return ToolCallType_TOOL_CALL_TYPE_INVALID
}

func (x *ToolCall) GetStatus() ToolCallStatus {
	if x != nil {
		return x.Status
	}
	return ToolCallStatus_TOOL_CALL_STATUS_IN_PROGRESS
}

func (x *ToolCall) GetErrorMessage() string {
	if x != nil && x.ErrorMessage != nil {
		return *x.ErrorMessage
	}
	return ""
}

func (x *ToolCall) GetTool() isToolCall_Tool {
	if x != nil {
		return x.Tool
	}
	return nil
}

func (x *ToolCall) GetFunction() *FunctionCall {
	if x != nil {
		if x, ok := x.Tool.(*ToolCall_Function); ok {
			return x.Function
		}
	}
	return nil
}

type isToolCall_Tool interface {
	isToolCall_Tool()
}

type ToolCall_Function struct {
	Function *FunctionCall `protobuf:"bytes,10,opt,name=function,proto3,oneof"`
}

func (*ToolCall_Function) isToolCall_Tool() {}

// Tool call information.
type FunctionCall struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name of the function to call.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Arguments used to call the function as json string.
	Arguments     string `protobuf:"bytes,2,opt,name=arguments,proto3" json:"arguments,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FunctionCall) Reset() {
	*x = FunctionCall{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FunctionCall) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FunctionCall) ProtoMessage() {}

func (x *FunctionCall) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FunctionCall.ProtoReflect.Descriptor instead.
func (*FunctionCall) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{24}
}

func (x *FunctionCall) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *FunctionCall) GetArguments() string {
	if x != nil {
		return x.Arguments
	}
	return ""
}

// The response format for structured response.
type ResponseFormat struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Type of format expected for the response. Default to `FORMAT_TYPE_TEXT`
	FormatType FormatType `protobuf:"varint,1,opt,name=format_type,json=formatType,proto3,enum=xai_api.FormatType" json:"format_type,omitempty"`
	// The JSON schema that the response should conform to.
	// Only considered if `format_type` is `FORMAT_TYPE_JSON_SCHEMA`.
	Schema        *string `protobuf:"bytes,2,opt,name=schema,proto3,oneof" json:"schema,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ResponseFormat) Reset() {
	*x = ResponseFormat{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResponseFormat) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResponseFormat) ProtoMessage() {}

func (x *ResponseFormat) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResponseFormat.ProtoReflect.Descriptor instead.
func (*ResponseFormat) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{25}
}

func (x *ResponseFormat) GetFormatType() FormatType {
	if x != nil {
		return x.FormatType
	}
	return FormatType_FORMAT_TYPE_INVALID
}

func (x *ResponseFormat) GetSchema() string {
	if x != nil && x.Schema != nil {
		return *x.Schema
	}
	return ""
}

// Parameters for configuring search behavior in a chat request.
//
// This message allows customization of search functionality when using models that support
// searching external sources for information. You can specify which sources to search,
// set date ranges for relevant content, control the search mode, and configure how
// results are returned.
type SearchParameters struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Controls when search is performed. Possible values are:
	//   - OFF_SEARCH_MODE (default): No search is performed, and no external data will be considered.
	//   - ON_SEARCH_MODE: Search is always performed when sampling from the model and the model will search in every source provided for relevant data.
	//   - AUTO_SEARCH_MODE: The model decides whether to perform a search based on the prompt and which sources to use.
	Mode SearchMode `protobuf:"varint,1,opt,name=mode,proto3,enum=xai_api.SearchMode" json:"mode,omitempty"`
	// A list of search sources to query, such as web, news, X, or RSS feeds.
	// Multiple sources can be specified. If no sources are provided, the model will default to
	// searching the web and X.
	Sources []*Source `protobuf:"bytes,9,rep,name=sources,proto3" json:"sources,omitempty"`
	// Optional start date for search results in ISO-8601 YYYY-MM-DD format (e.g., "2024-05-24").
	// Only content after this date will be considered. Defaults to unset (no start date restriction).
	// See https://en.wikipedia.org/wiki/ISO_8601 for format details.
	FromDate *timestamppb.Timestamp `protobuf:"bytes,4,opt,name=from_date,json=fromDate,proto3" json:"from_date,omitempty"`
	// Optional end date for search results in ISO-8601 YYYY-MM-DD format (e.g., "2024-12-24").
	// Only content before this date will be considered. Defaults to unset (no end date restriction).
	// See https://en.wikipedia.org/wiki/ISO_8601 for format details.
	ToDate *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=to_date,json=toDate,proto3" json:"to_date,omitempty"`
	// If set to true, the model will return a list of citations (URLs or references)
	// to the sources used in generating the response. Defaults to true.
	ReturnCitations bool `protobuf:"varint,7,opt,name=return_citations,json=returnCitations,proto3" json:"return_citations,omitempty"`
	// Optional limit on the number of search results to consider
	// when generating a response. Must be in the range [1, 30]. Defaults to 15.
	MaxSearchResults *int32 `protobuf:"varint,8,opt,name=max_search_results,json=maxSearchResults,proto3,oneof" json:"max_search_results,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *SearchParameters) Reset() {
	*x = SearchParameters{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SearchParameters) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SearchParameters) ProtoMessage() {}

func (x *SearchParameters) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SearchParameters.ProtoReflect.Descriptor instead.
func (*SearchParameters) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{26}
}

func (x *SearchParameters) GetMode() SearchMode {
	if x != nil {
		return x.Mode
	}
	return SearchMode_INVALID_SEARCH_MODE
}

func (x *SearchParameters) GetSources() []*Source {
	if x != nil {
		return x.Sources
	}
	return nil
}

func (x *SearchParameters) GetFromDate() *timestamppb.Timestamp {
	if x != nil {
		return x.FromDate
	}
	return nil
}

func (x *SearchParameters) GetToDate() *timestamppb.Timestamp {
	if x != nil {
		return x.ToDate
	}
	return nil
}

func (x *SearchParameters) GetReturnCitations() bool {
	if x != nil {
		return x.ReturnCitations
	}
	return false
}

func (x *SearchParameters) GetMaxSearchResults() int32 {
	if x != nil && x.MaxSearchResults != nil {
		return *x.MaxSearchResults
	}
	return 0
}

// Defines a source for search requests, specifying the type of content to search.
// This message acts as a container for different types of search sources. Only one type
// of source can be specified per instance using the oneof field.
type Source struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to Source:
	//
	//	*Source_Web
	//	*Source_News
	//	*Source_X
	//	*Source_Rss
	Source        isSource_Source `protobuf_oneof:"source"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Source) Reset() {
	*x = Source{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Source) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Source) ProtoMessage() {}

func (x *Source) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Source.ProtoReflect.Descriptor instead.
func (*Source) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{27}
}

func (x *Source) GetSource() isSource_Source {
	if x != nil {
		return x.Source
	}
	return nil
}

func (x *Source) GetWeb() *WebSource {
	if x != nil {
		if x, ok := x.Source.(*Source_Web); ok {
			return x.Web
		}
	}
	return nil
}

func (x *Source) GetNews() *NewsSource {
	if x != nil {
		if x, ok := x.Source.(*Source_News); ok {
			return x.News
		}
	}
	return nil
}

func (x *Source) GetX() *XSource {
	if x != nil {
		if x, ok := x.Source.(*Source_X); ok {
			return x.X
		}
	}
	return nil
}

func (x *Source) GetRss() *RssSource {
	if x != nil {
		if x, ok := x.Source.(*Source_Rss); ok {
			return x.Rss
		}
	}
	return nil
}

type isSource_Source interface {
	isSource_Source()
}

type Source_Web struct {
	// Configuration for searching online web content. Use this to search general websites
	// with options to filter by country, exclude specific domains, or only allow specific domains.
	Web *WebSource `protobuf:"bytes,1,opt,name=web,proto3,oneof"`
}

type Source_News struct {
	// Configuration for searching recent articles and reports from news outlets.
	// Useful for current events or topic-specific updates.
	News *NewsSource `protobuf:"bytes,2,opt,name=news,proto3,oneof"`
}

type Source_X struct {
	// Configuration for searching content on X. Allows focusing on
	// specific user handles for targeted content.
	X *XSource `protobuf:"bytes,3,opt,name=x,proto3,oneof"`
}

type Source_Rss struct {
	// Configuration for searching content from RSS feeds. Requires specific feed URLs
	// to query.
	Rss *RssSource `protobuf:"bytes,4,opt,name=rss,proto3,oneof"`
}

func (*Source_Web) isSource_Source() {}

func (*Source_News) isSource_Source() {}

func (*Source_X) isSource_Source() {}

func (*Source_Rss) isSource_Source() {}

// Configuration for a web search source in search requests.
//
// This message configures a source for searching online web content. It allows specification
// of regional content through country codes and filtering of results by excluding or allowing
// specific websites.
type WebSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of website domains (without protocol specification or subdomains) to exclude from search results (e.g., ["example.com"]).
	// Use this to prevent results from unwanted sites. A maximum of 5 websites can be excluded.
	// This parameter cannot be set together with `allowed_websites`.
	ExcludedWebsites []string `protobuf:"bytes,2,rep,name=excluded_websites,json=excludedWebsites,proto3" json:"excluded_websites,omitempty"`
	// List of website domains (without protocol specification or subdomains)
	// to restrict search results to (e.g., ["example.com"]). A maximum of 5 websites can be allowed.
	// Use this as a whitelist to limit results to only these specific sites; no other websites will
	// be considered. If no relevant information is found on these websites, the number of results
	// returned might be smaller than `max_search_results` set in `SearchParameters`. Note: This
	// parameter cannot be set together with `excluded_websites`.
	AllowedWebsites []string `protobuf:"bytes,5,rep,name=allowed_websites,json=allowedWebsites,proto3" json:"allowed_websites,omitempty"`
	// Optional ISO alpha-2 country code (e.g., "BE" for Belgium) to limit search results
	// to content from a specific region or country. Defaults to unset (global search).
	// See https://en.wikipedia.org/wiki/ISO_3166-2 for valid codes.
	Country *string `protobuf:"bytes,3,opt,name=country,proto3,oneof" json:"country,omitempty"`
	// Whether to exclude adult content from the search results. Defaults to true.
	SafeSearch    bool `protobuf:"varint,4,opt,name=safe_search,json=safeSearch,proto3" json:"safe_search,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *WebSource) Reset() {
	*x = WebSource{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *WebSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*WebSource) ProtoMessage() {}

func (x *WebSource) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use WebSource.ProtoReflect.Descriptor instead.
func (*WebSource) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{28}
}

func (x *WebSource) GetExcludedWebsites() []string {
	if x != nil {
		return x.ExcludedWebsites
	}
	return nil
}

func (x *WebSource) GetAllowedWebsites() []string {
	if x != nil {
		return x.AllowedWebsites
	}
	return nil
}

func (x *WebSource) GetCountry() string {
	if x != nil && x.Country != nil {
		return *x.Country
	}
	return ""
}

func (x *WebSource) GetSafeSearch() bool {
	if x != nil {
		return x.SafeSearch
	}
	return false
}

// Configuration for a news search source in search requests.
//
// This message configures a source for searching recent articles and reports from news outlets.
// It is useful for obtaining current events or topic-specific updates with regional filtering.
type NewsSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of website domains (without protocol specification or subdomains)
	// to exclude from search results (e.g., ["example.com"]). A maximum of 5 websites can be excluded.
	// Use this to prevent results from specific news sites. Defaults to unset (no exclusions).
	ExcludedWebsites []string `protobuf:"bytes,2,rep,name=excluded_websites,json=excludedWebsites,proto3" json:"excluded_websites,omitempty"`
	// Optional ISO alpha-2 country code (e.g., "BE" for Belgium) to limit search results
	// to news from a specific region or country. Defaults to unset (global news).
	// See https://en.wikipedia.org/wiki/ISO_3166-2 for valid codes.
	Country *string `protobuf:"bytes,3,opt,name=country,proto3,oneof" json:"country,omitempty"`
	// Whether to exclude adult content from the search results. Defaults to true.
	SafeSearch    bool `protobuf:"varint,4,opt,name=safe_search,json=safeSearch,proto3" json:"safe_search,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *NewsSource) Reset() {
	*x = NewsSource{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *NewsSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*NewsSource) ProtoMessage() {}

func (x *NewsSource) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use NewsSource.ProtoReflect.Descriptor instead.
func (*NewsSource) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{29}
}

func (x *NewsSource) GetExcludedWebsites() []string {
	if x != nil {
		return x.ExcludedWebsites
	}
	return nil
}

func (x *NewsSource) GetCountry() string {
	if x != nil && x.Country != nil {
		return *x.Country
	}
	return ""
}

func (x *NewsSource) GetSafeSearch() bool {
	if x != nil {
		return x.SafeSearch
	}
	return false
}

// Configuration for an X (formerly Twitter) search source in search requests.
//
// This message configures a source for searching content on X. It allows focusing the search
// on specific user handles to retrieve targeted posts and interactions.
type XSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Optional list of X usernames (without the '@' symbol) to limit search results to posts
	// from specific accounts (e.g., ["xai"]). If set, only posts authored by these
	// handles will be considered in the live search.
	// This field can not be set together with `excluded_x_handles`.
	// Defaults to unset (no exclusions).
	IncludedXHandles []string `protobuf:"bytes,7,rep,name=included_x_handles,json=includedXHandles,proto3" json:"included_x_handles,omitempty"`
	// Optional list of X usernames (without the '@' symbol) used to exclude posts from specific accounts.
	// If set, posts authored by these handles will be excluded from the live search results.
	// This field can not be set together with `included_x_handles`.
	// Defaults to unset (no exclusions).
	ExcludedXHandles []string `protobuf:"bytes,8,rep,name=excluded_x_handles,json=excludedXHandles,proto3" json:"excluded_x_handles,omitempty"`
	// Optional post favorite count threshold. Defaults to unset (don't filter posts by post favorite count).
	// If set, only posts with a favorite count greater than or equal to this threshold will be considered.
	PostFavoriteCount *int32 `protobuf:"varint,9,opt,name=post_favorite_count,json=postFavoriteCount,proto3,oneof" json:"post_favorite_count,omitempty"`
	// Optional post view count threshold. Defaults to unset (don't filter posts by post view count).
	// If set, only posts with a view count greater than or equal to this threshold will be considered.
	PostViewCount *int32 `protobuf:"varint,10,opt,name=post_view_count,json=postViewCount,proto3,oneof" json:"post_view_count,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *XSource) Reset() {
	*x = XSource{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *XSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*XSource) ProtoMessage() {}

func (x *XSource) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use XSource.ProtoReflect.Descriptor instead.
func (*XSource) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{30}
}

func (x *XSource) GetIncludedXHandles() []string {
	if x != nil {
		return x.IncludedXHandles
	}
	return nil
}

func (x *XSource) GetExcludedXHandles() []string {
	if x != nil {
		return x.ExcludedXHandles
	}
	return nil
}

func (x *XSource) GetPostFavoriteCount() int32 {
	if x != nil && x.PostFavoriteCount != nil {
		return *x.PostFavoriteCount
	}
	return 0
}

func (x *XSource) GetPostViewCount() int32 {
	if x != nil && x.PostViewCount != nil {
		return *x.PostViewCount
	}
	return 0
}

// Configuration for an RSS search source in search requests.
//
// This message configures a source for searching content from RSS feeds. It requires specific
// feed URLs to query for content updates.
type RssSource struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// List of RSS feed URLs to search. Each URL must point to a valid RSS feed.
	// At least one link must be provided.
	Links         []string `protobuf:"bytes,1,rep,name=links,proto3" json:"links,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RssSource) Reset() {
	*x = RssSource{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RssSource) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RssSource) ProtoMessage() {}

func (x *RssSource) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RssSource.ProtoReflect.Descriptor instead.
func (*RssSource) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{31}
}

func (x *RssSource) GetLinks() []string {
	if x != nil {
		return x.Links
	}
	return nil
}

type RequestSettings struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Max number of tokens that can be generated in a response. This includes both output and reasoning tokens.
	MaxTokens *int32 `protobuf:"varint,1,opt,name=max_tokens,json=maxTokens,proto3,oneof" json:"max_tokens,omitempty"`
	// / If set to false, the model can perform maximum one tool call. Default to true.
	ParallelToolCalls bool `protobuf:"varint,2,opt,name=parallel_tool_calls,json=parallelToolCalls,proto3" json:"parallel_tool_calls,omitempty"`
	// The ID of the previous response from the model.
	PreviousResponseId *string `protobuf:"bytes,3,opt,name=previous_response_id,json=previousResponseId,proto3,oneof" json:"previous_response_id,omitempty"`
	// Constrains effort on reasoning for reasoning models. Default to `EFFORT_MEDIUM`.
	ReasoningEffort *ReasoningEffort `protobuf:"varint,4,opt,name=reasoning_effort,json=reasoningEffort,proto3,enum=xai_api.ReasoningEffort,oneof" json:"reasoning_effort,omitempty"`
	// A number between 0 and 2 used to control the variance of completions.
	// The smaller the value, the more deterministic the model will become. For
	// example, if we sample 1000 answers to the same prompt at a temperature of
	// 0.001, then most of the 1000 answers will be identical. Conversely, if we
	// conduct the same experiment at a temperature of 2, virtually no two answers
	// will be identical. Note that increasing the temperature will cause
	// the model to hallucinate more strongly.
	Temperature *float32 `protobuf:"fixed32,5,opt,name=temperature,proto3,oneof" json:"temperature,omitempty"`
	// Formatting constraint on the response.
	ResponseFormat *ResponseFormat `protobuf:"bytes,6,opt,name=response_format,json=responseFormat,proto3" json:"response_format,omitempty"`
	// Controls if the model can, should, or must not use tools.
	ToolChoice *ToolChoice `protobuf:"bytes,7,opt,name=tool_choice,json=toolChoice,proto3" json:"tool_choice,omitempty"`
	// A list of tools the model may call. Currently, only functions are supported
	// as a tool. Use this to provide a list of functions the model may generate
	// JSON inputs for.
	Tools []*Tool `protobuf:"bytes,8,rep,name=tools,proto3" json:"tools,omitempty"`
	// A number between 0 and 1 controlling the likelihood of the model to use
	// less-common answers. Recall that the model produces a probability for
	// each token. This means, for any choice of token there are thousands of
	// possibilities to choose from. This parameter controls the "nucleus sampling
	// algorithm". Instead of considering every possible token at every step, we
	// only look at the K tokens who's probabilities exceed `top_p`.
	// For example, if we set `top_p = 0.9`, then the set of tokens we actually
	// sample from, will have a probability mass of at least 90%. In practice,
	// low values will make the model more deterministic.
	TopP *float32 `protobuf:"fixed32,9,opt,name=top_p,json=topP,proto3,oneof" json:"top_p,omitempty"`
	// An opaque string supplied by the API client (customer) to identify a user.
	// The string will be stored in the logs and can be used in customer service
	// requests to identify certain requests.
	User string `protobuf:"bytes,10,opt,name=user,proto3" json:"user,omitempty"`
	// Set the parameters to be used for realtime data. If not set, no realtime data will be acquired by the model.
	SearchParameters *SearchParameters `protobuf:"bytes,11,opt,name=search_parameters,json=searchParameters,proto3,oneof" json:"search_parameters,omitempty"`
	// Whether to store request and responses. Default is false.
	StoreMessages bool `protobuf:"varint,12,opt,name=store_messages,json=storeMessages,proto3" json:"store_messages,omitempty"`
	// Whether to use encrypted thinking for thinking trace rehydration.
	UseEncryptedContent bool `protobuf:"varint,13,opt,name=use_encrypted_content,json=useEncryptedContent,proto3" json:"use_encrypted_content,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *RequestSettings) Reset() {
	*x = RequestSettings{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RequestSettings) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RequestSettings) ProtoMessage() {}

func (x *RequestSettings) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RequestSettings.ProtoReflect.Descriptor instead.
func (*RequestSettings) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{32}
}

func (x *RequestSettings) GetMaxTokens() int32 {
	if x != nil && x.MaxTokens != nil {
		return *x.MaxTokens
	}
	return 0
}

func (x *RequestSettings) GetParallelToolCalls() bool {
	if x != nil {
		return x.ParallelToolCalls
	}
	return false
}

func (x *RequestSettings) GetPreviousResponseId() string {
	if x != nil && x.PreviousResponseId != nil {
		return *x.PreviousResponseId
	}
	return ""
}

func (x *RequestSettings) GetReasoningEffort() ReasoningEffort {
	if x != nil && x.ReasoningEffort != nil {
		return *x.ReasoningEffort
	}
	return ReasoningEffort_INVALID_EFFORT
}

func (x *RequestSettings) GetTemperature() float32 {
	if x != nil && x.Temperature != nil {
		return *x.Temperature
	}
	return 0
}

func (x *RequestSettings) GetResponseFormat() *ResponseFormat {
	if x != nil {
		return x.ResponseFormat
	}
	return nil
}

func (x *RequestSettings) GetToolChoice() *ToolChoice {
	if x != nil {
		return x.ToolChoice
	}
	return nil
}

func (x *RequestSettings) GetTools() []*Tool {
	if x != nil {
		return x.Tools
	}
	return nil
}

func (x *RequestSettings) GetTopP() float32 {
	if x != nil && x.TopP != nil {
		return *x.TopP
	}
	return 0
}

func (x *RequestSettings) GetUser() string {
	if x != nil {
		return x.User
	}
	return ""
}

func (x *RequestSettings) GetSearchParameters() *SearchParameters {
	if x != nil {
		return x.SearchParameters
	}
	return nil
}

func (x *RequestSettings) GetStoreMessages() bool {
	if x != nil {
		return x.StoreMessages
	}
	return false
}

func (x *RequestSettings) GetUseEncryptedContent() bool {
	if x != nil {
		return x.UseEncryptedContent
	}
	return false
}

// Request to retrieve a stored completion response.
type GetStoredCompletionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The response id to be retrieved.
	ResponseId    string `protobuf:"bytes,1,opt,name=response_id,json=responseId,proto3" json:"response_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetStoredCompletionRequest) Reset() {
	*x = GetStoredCompletionRequest{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetStoredCompletionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetStoredCompletionRequest) ProtoMessage() {}

func (x *GetStoredCompletionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetStoredCompletionRequest.ProtoReflect.Descriptor instead.
func (*GetStoredCompletionRequest) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{33}
}

func (x *GetStoredCompletionRequest) GetResponseId() string {
	if x != nil {
		return x.ResponseId
	}
	return ""
}

// Request to delete a stored completion response.
type DeleteStoredCompletionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The response id to be deleted.
	ResponseId    string `protobuf:"bytes,1,opt,name=response_id,json=responseId,proto3" json:"response_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteStoredCompletionRequest) Reset() {
	*x = DeleteStoredCompletionRequest{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteStoredCompletionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteStoredCompletionRequest) ProtoMessage() {}

func (x *DeleteStoredCompletionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteStoredCompletionRequest.ProtoReflect.Descriptor instead.
func (*DeleteStoredCompletionRequest) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{34}
}

func (x *DeleteStoredCompletionRequest) GetResponseId() string {
	if x != nil {
		return x.ResponseId
	}
	return ""
}

// Response for deleting a stored completion.
type DeleteStoredCompletionResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The response id that was deleted.
	ResponseId    string `protobuf:"bytes,1,opt,name=response_id,json=responseId,proto3" json:"response_id,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteStoredCompletionResponse) Reset() {
	*x = DeleteStoredCompletionResponse{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteStoredCompletionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteStoredCompletionResponse) ProtoMessage() {}

func (x *DeleteStoredCompletionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteStoredCompletionResponse.ProtoReflect.Descriptor instead.
func (*DeleteStoredCompletionResponse) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{35}
}

func (x *DeleteStoredCompletionResponse) GetResponseId() string {
	if x != nil {
		return x.ResponseId
	}
	return ""
}

// Holds debug information. Only available to trusted testers.
type DebugOutput struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Number of attempts made to the model.
	Attempts int32 `protobuf:"varint,1,opt,name=attempts,proto3" json:"attempts,omitempty"`
	// The request received from the user.
	Request string `protobuf:"bytes,2,opt,name=request,proto3" json:"request,omitempty"`
	// The prompt sent to the model in text form.
	Prompt string `protobuf:"bytes,3,opt,name=prompt,proto3" json:"prompt,omitempty"`
	// The JSON-serialized request sent to the inference engine.
	EngineRequest string `protobuf:"bytes,9,opt,name=engine_request,json=engineRequest,proto3" json:"engine_request,omitempty"`
	// The response(s) received from the model.
	Responses []string `protobuf:"bytes,4,rep,name=responses,proto3" json:"responses,omitempty"`
	// The raw chunks returned from the pipeline of samplers.
	Chunks []string `protobuf:"bytes,12,rep,name=chunks,proto3" json:"chunks,omitempty"`
	// Number of cache reads
	CacheReadCount uint32 `protobuf:"varint,5,opt,name=cache_read_count,json=cacheReadCount,proto3" json:"cache_read_count,omitempty"`
	// Size of cache read
	CacheReadInputBytes uint64 `protobuf:"varint,6,opt,name=cache_read_input_bytes,json=cacheReadInputBytes,proto3" json:"cache_read_input_bytes,omitempty"`
	// Number of cache writes
	CacheWriteCount uint32 `protobuf:"varint,7,opt,name=cache_write_count,json=cacheWriteCount,proto3" json:"cache_write_count,omitempty"`
	// Size of cache write
	CacheWriteInputBytes uint64 `protobuf:"varint,8,opt,name=cache_write_input_bytes,json=cacheWriteInputBytes,proto3" json:"cache_write_input_bytes,omitempty"`
	// The lb address header
	LbAddress string `protobuf:"bytes,10,opt,name=lb_address,json=lbAddress,proto3" json:"lb_address,omitempty"`
	// The tag of the sampler that served this request.
	SamplerTag    string `protobuf:"bytes,11,opt,name=sampler_tag,json=samplerTag,proto3" json:"sampler_tag,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DebugOutput) Reset() {
	*x = DebugOutput{}
	mi := &file_xai_api_v1_chat_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DebugOutput) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DebugOutput) ProtoMessage() {}

func (x *DebugOutput) ProtoReflect() protoreflect.Message {
	mi := &file_xai_api_v1_chat_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DebugOutput.ProtoReflect.Descriptor instead.
func (*DebugOutput) Descriptor() ([]byte, []int) {
	return file_xai_api_v1_chat_proto_rawDescGZIP(), []int{36}
}

func (x *DebugOutput) GetAttempts() int32 {
	if x != nil {
		return x.Attempts
	}
	return 0
}

func (x *DebugOutput) GetRequest() string {
	if x != nil {
		return x.Request
	}
	return ""
}

func (x *DebugOutput) GetPrompt() string {
	if x != nil {
		return x.Prompt
	}
	return ""
}

func (x *DebugOutput) GetEngineRequest() string {
	if x != nil {
		return x.EngineRequest
	}
	return ""
}

func (x *DebugOutput) GetResponses() []string {
	if x != nil {
		return x.Responses
	}
	return nil
}

func (x *DebugOutput) GetChunks() []string {
	if x != nil {
		return x.Chunks
	}
	return nil
}

func (x *DebugOutput) GetCacheReadCount() uint32 {
	if x != nil {
		return x.CacheReadCount
	}
	return 0
}

func (x *DebugOutput) GetCacheReadInputBytes() uint64 {
	if x != nil {
		return x.CacheReadInputBytes
	}
	return 0
}

func (x *DebugOutput) GetCacheWriteCount() uint32 {
	if x != nil {
		return x.CacheWriteCount
	}
	return 0
}

func (x *DebugOutput) GetCacheWriteInputBytes() uint64 {
	if x != nil {
		return x.CacheWriteInputBytes
	}
	return 0
}

func (x *DebugOutput) GetLbAddress() string {
	if x != nil {
		return x.LbAddress
	}
	return ""
}

func (x *DebugOutput) GetSamplerTag() string {
	if x != nil {
		return x.SamplerTag
	}
	return ""
}

var File_xai_api_v1_chat_proto protoreflect.FileDescriptor

const file_xai_api_v1_chat_proto_rawDesc = "" +
	"\n" +
	"\x15xai/api/v1/chat.proto\x12\axai_api\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x19xai/api/v1/deferred.proto\x1a\x16xai/api/v1/image.proto\x1a\x17xai/api/v1/sample.proto\x1a\x16xai/api/v1/usage.proto\"\xbb\t\n" +
	"\x15GetCompletionsRequest\x12,\n" +
	"\bmessages\x18\x01 \x03(\v2\x10.xai_api.MessageR\bmessages\x12\x14\n" +
	"\x05model\x18\x02 \x01(\tR\x05model\x12\x12\n" +
	"\x04user\x18\x10 \x01(\tR\x04user\x12\x11\n" +
	"\x01n\x18\b \x01(\x05H\x00R\x01n\x88\x01\x01\x12\"\n" +
	"\n" +
	"max_tokens\x18\a \x01(\x05H\x01R\tmaxTokens\x88\x01\x01\x12\x17\n" +
	"\x04seed\x18\v \x01(\x05H\x02R\x04seed\x88\x01\x01\x12\x12\n" +
	"\x04stop\x18\f \x03(\tR\x04stop\x12%\n" +
	"\vtemperature\x18\x0e \x01(\x02H\x03R\vtemperature\x88\x01\x01\x12\x18\n" +
	"\x05top_p\x18\x0f \x01(\x02H\x04R\x04topP\x88\x01\x01\x12\x1a\n" +
	"\blogprobs\x18\x05 \x01(\bR\blogprobs\x12&\n" +
	"\ftop_logprobs\x18\x06 \x01(\x05H\x05R\vtopLogprobs\x88\x01\x01\x12#\n" +
	"\x05tools\x18\x11 \x03(\v2\r.xai_api.ToolR\x05tools\x124\n" +
	"\vtool_choice\x18\x12 \x01(\v2\x13.xai_api.ToolChoiceR\n" +
	"toolChoice\x12@\n" +
	"\x0fresponse_format\x18\n" +
	" \x01(\v2\x17.xai_api.ResponseFormatR\x0eresponseFormat\x120\n" +
	"\x11frequency_penalty\x18\x03 \x01(\x02H\x06R\x10frequencyPenalty\x88\x01\x01\x12.\n" +
	"\x10presence_penalty\x18\t \x01(\x02H\aR\x0fpresencePenalty\x88\x01\x01\x12H\n" +
	"\x10reasoning_effort\x18\x13 \x01(\x0e2\x18.xai_api.ReasoningEffortH\bR\x0freasoningEffort\x88\x01\x01\x12K\n" +
	"\x11search_parameters\x18\x14 \x01(\v2\x19.xai_api.SearchParametersH\tR\x10searchParameters\x88\x01\x01\x123\n" +
	"\x13parallel_tool_calls\x18\x15 \x01(\bH\n" +
	"R\x11parallelToolCalls\x88\x01\x01\x125\n" +
	"\x14previous_response_id\x18\x16 \x01(\tH\vR\x12previousResponseId\x88\x01\x01\x12%\n" +
	"\x0estore_messages\x18\x17 \x01(\bR\rstoreMessages\x122\n" +
	"\x15use_encrypted_content\x18\x18 \x01(\bR\x13useEncryptedContent\x12 \n" +
	"\tmax_turns\x18\x19 \x01(\x05H\fR\bmaxTurns\x88\x01\x01B\x04\n" +
	"\x02_nB\r\n" +
	"\v_max_tokensB\a\n" +
	"\x05_seedB\x0e\n" +
	"\f_temperatureB\b\n" +
	"\x06_top_pB\x0f\n" +
	"\r_top_logprobsB\x14\n" +
	"\x12_frequency_penaltyB\x13\n" +
	"\x11_presence_penaltyB\x13\n" +
	"\x11_reasoning_effortB\x14\n" +
	"\x12_search_parametersB\x16\n" +
	"\x14_parallel_tool_callsB\x17\n" +
	"\x15_previous_response_idB\f\n" +
	"\n" +
	"_max_turnsJ\x04\b\x04\x10\x05\"\x96\x03\n" +
	"\x19GetChatCompletionResponse\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x123\n" +
	"\aoutputs\x18\x02 \x03(\v2\x19.xai_api.CompletionOutputR\aoutputs\x124\n" +
	"\acreated\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\acreated\x12\x14\n" +
	"\x05model\x18\x06 \x01(\tR\x05model\x12-\n" +
	"\x12system_fingerprint\x18\a \x01(\tR\x11systemFingerprint\x12,\n" +
	"\x05usage\x18\t \x01(\v2\x16.xai_api.SamplingUsageR\x05usage\x12\x1c\n" +
	"\tcitations\x18\n" +
	" \x03(\tR\tcitations\x124\n" +
	"\bsettings\x18\v \x01(\v2\x18.xai_api.RequestSettingsR\bsettings\x127\n" +
	"\fdebug_output\x18\f \x01(\v2\x14.xai_api.DebugOutputR\vdebugOutput\"\xe2\x02\n" +
	"\x16GetChatCompletionChunk\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x128\n" +
	"\aoutputs\x18\x02 \x03(\v2\x1e.xai_api.CompletionOutputChunkR\aoutputs\x124\n" +
	"\acreated\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\acreated\x12\x14\n" +
	"\x05model\x18\x04 \x01(\tR\x05model\x12-\n" +
	"\x12system_fingerprint\x18\x05 \x01(\tR\x11systemFingerprint\x12,\n" +
	"\x05usage\x18\x06 \x01(\v2\x16.xai_api.SamplingUsageR\x05usage\x12\x1c\n" +
	"\tcitations\x18\a \x03(\tR\tcitations\x127\n" +
	"\fdebug_output\x18\n" +
	" \x01(\v2\x14.xai_api.DebugOutputR\vdebugOutput\"\xa2\x01\n" +
	"\x1dGetDeferredCompletionResponse\x12/\n" +
	"\x06status\x18\x02 \x01(\x0e2\x17.xai_api.DeferredStatusR\x06status\x12C\n" +
	"\bresponse\x18\x01 \x01(\v2\".xai_api.GetChatCompletionResponseH\x00R\bresponse\x88\x01\x01B\v\n" +
	"\t_response\"\xc9\x01\n" +
	"\x10CompletionOutput\x12:\n" +
	"\rfinish_reason\x18\x01 \x01(\x0e2\x15.xai_api.FinishReasonR\ffinishReason\x12\x14\n" +
	"\x05index\x18\x02 \x01(\x05R\x05index\x124\n" +
	"\amessage\x18\x03 \x01(\v2\x1a.xai_api.CompletionMessageR\amessage\x12-\n" +
	"\blogprobs\x18\x04 \x01(\v2\x11.xai_api.LogProbsR\blogprobs\"\xe3\x01\n" +
	"\x11CompletionMessage\x12\x18\n" +
	"\acontent\x18\x01 \x01(\tR\acontent\x12+\n" +
	"\x11reasoning_content\x18\x04 \x01(\tR\x10reasoningContent\x12(\n" +
	"\x04role\x18\x02 \x01(\x0e2\x14.xai_api.MessageRoleR\x04role\x120\n" +
	"\n" +
	"tool_calls\x18\x03 \x03(\v2\x11.xai_api.ToolCallR\ttoolCalls\x12+\n" +
	"\x11encrypted_content\x18\x05 \x01(\tR\x10encryptedContent\"\xbe\x01\n" +
	"\x15CompletionOutputChunk\x12$\n" +
	"\x05delta\x18\x01 \x01(\v2\x0e.xai_api.DeltaR\x05delta\x12-\n" +
	"\blogprobs\x18\x02 \x01(\v2\x11.xai_api.LogProbsR\blogprobs\x12:\n" +
	"\rfinish_reason\x18\x03 \x01(\x0e2\x15.xai_api.FinishReasonR\ffinishReason\x12\x14\n" +
	"\x05index\x18\x04 \x01(\x05R\x05index\"\xd7\x01\n" +
	"\x05Delta\x12\x18\n" +
	"\acontent\x18\x01 \x01(\tR\acontent\x12+\n" +
	"\x11reasoning_content\x18\x04 \x01(\tR\x10reasoningContent\x12(\n" +
	"\x04role\x18\x02 \x01(\x0e2\x14.xai_api.MessageRoleR\x04role\x120\n" +
	"\n" +
	"tool_calls\x18\x03 \x03(\v2\x11.xai_api.ToolCallR\ttoolCalls\x12+\n" +
	"\x11encrypted_content\x18\x05 \x01(\tR\x10encryptedContent\"6\n" +
	"\bLogProbs\x12*\n" +
	"\acontent\x18\x01 \x03(\v2\x10.xai_api.LogProbR\acontent\"\x87\x01\n" +
	"\aLogProb\x12\x14\n" +
	"\x05token\x18\x01 \x01(\tR\x05token\x12\x18\n" +
	"\alogprob\x18\x02 \x01(\x02R\alogprob\x12\x14\n" +
	"\x05bytes\x18\x03 \x01(\fR\x05bytes\x126\n" +
	"\ftop_logprobs\x18\x04 \x03(\v2\x13.xai_api.TopLogProbR\vtopLogprobs\"R\n" +
	"\n" +
	"TopLogProb\x12\x14\n" +
	"\x05token\x18\x01 \x01(\tR\x05token\x12\x18\n" +
	"\alogprob\x18\x02 \x01(\x02R\alogprob\x12\x14\n" +
	"\x05bytes\x18\x03 \x01(\fR\x05bytes\"\x8f\x01\n" +
	"\aContent\x12\x14\n" +
	"\x04text\x18\x01 \x01(\tH\x00R\x04text\x127\n" +
	"\timage_url\x18\x02 \x01(\v2\x18.xai_api.ImageUrlContentH\x00R\bimageUrl\x12*\n" +
	"\x04file\x18\x03 \x01(\v2\x14.xai_api.FileContentH\x00R\x04fileB\t\n" +
	"\acontent\"&\n" +
	"\vFileContent\x12\x17\n" +
	"\afile_id\x18\x01 \x01(\tR\x06fileId\"\x9a\x02\n" +
	"\aMessage\x12*\n" +
	"\acontent\x18\x01 \x03(\v2\x10.xai_api.ContentR\acontent\x120\n" +
	"\x11reasoning_content\x18\x05 \x01(\tH\x00R\x10reasoningContent\x88\x01\x01\x12(\n" +
	"\x04role\x18\x02 \x01(\x0e2\x14.xai_api.MessageRoleR\x04role\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x120\n" +
	"\n" +
	"tool_calls\x18\x04 \x03(\v2\x11.xai_api.ToolCallR\ttoolCalls\x12+\n" +
	"\x11encrypted_content\x18\x06 \x01(\tR\x10encryptedContentB\x14\n" +
	"\x12_reasoning_content\"k\n" +
	"\n" +
	"ToolChoice\x12'\n" +
	"\x04mode\x18\x01 \x01(\x0e2\x11.xai_api.ToolModeH\x00R\x04mode\x12%\n" +
	"\rfunction_name\x18\x02 \x01(\tH\x00R\ffunctionNameB\r\n" +
	"\vtool_choice\"\x97\x03\n" +
	"\x04Tool\x12/\n" +
	"\bfunction\x18\x01 \x01(\v2\x11.xai_api.FunctionH\x00R\bfunction\x123\n" +
	"\n" +
	"web_search\x18\x03 \x01(\v2\x12.xai_api.WebSearchH\x00R\twebSearch\x12-\n" +
	"\bx_search\x18\x04 \x01(\v2\x10.xai_api.XSearchH\x00R\axSearch\x12?\n" +
	"\x0ecode_execution\x18\x05 \x01(\v2\x16.xai_api.CodeExecutionH\x00R\rcodeExecution\x12K\n" +
	"\x12collections_search\x18\x06 \x01(\v2\x1a.xai_api.CollectionsSearchH\x00R\x11collectionsSearch\x12 \n" +
	"\x03mcp\x18\a \x01(\v2\f.xai_api.MCPH\x00R\x03mcp\x12B\n" +
	"\x0fdocument_search\x18\b \x01(\v2\x17.xai_api.DocumentSearchH\x00R\x0edocumentSearchB\x06\n" +
	"\x04tool\"\xe7\x02\n" +
	"\x03MCP\x12!\n" +
	"\fserver_label\x18\x01 \x01(\tR\vserverLabel\x12-\n" +
	"\x12server_description\x18\x02 \x01(\tR\x11serverDescription\x12\x1d\n" +
	"\n" +
	"server_url\x18\x03 \x01(\tR\tserverUrl\x12,\n" +
	"\x12allowed_tool_names\x18\x04 \x03(\tR\x10allowedToolNames\x12)\n" +
	"\rauthorization\x18\x05 \x01(\tH\x00R\rauthorization\x88\x01\x01\x12C\n" +
	"\rextra_headers\x18\x06 \x03(\v2\x1e.xai_api.MCP.ExtraHeadersEntryR\fextraHeaders\x1a?\n" +
	"\x11ExtraHeadersEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value:\x028\x01B\x10\n" +
	"\x0e_authorization\"\xc1\x01\n" +
	"\tWebSearch\x12)\n" +
	"\x10excluded_domains\x18\x01 \x03(\tR\x0fexcludedDomains\x12'\n" +
	"\x0fallowed_domains\x18\x02 \x03(\tR\x0eallowedDomains\x12A\n" +
	"\x1aenable_image_understanding\x18\x03 \x01(\bH\x00R\x18enableImageUnderstanding\x88\x01\x01B\x1d\n" +
	"\x1b_enable_image_understanding\"\xb9\x03\n" +
	"\aXSearch\x12<\n" +
	"\tfrom_date\x18\x01 \x01(\v2\x1a.google.protobuf.TimestampH\x00R\bfromDate\x88\x01\x01\x128\n" +
	"\ato_date\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampH\x01R\x06toDate\x88\x01\x01\x12*\n" +
	"\x11allowed_x_handles\x18\x03 \x03(\tR\x0fallowedXHandles\x12,\n" +
	"\x12excluded_x_handles\x18\x04 \x03(\tR\x10excludedXHandles\x12A\n" +
	"\x1aenable_image_understanding\x18\x05 \x01(\bH\x02R\x18enableImageUnderstanding\x88\x01\x01\x12A\n" +
	"\x1aenable_video_understanding\x18\x06 \x01(\bH\x03R\x18enableVideoUnderstanding\x88\x01\x01B\f\n" +
	"\n" +
	"_from_dateB\n" +
	"\n" +
	"\b_to_dateB\x1d\n" +
	"\x1b_enable_image_understandingB\x1d\n" +
	"\x1b_enable_video_understanding\"\x0f\n" +
	"\rCodeExecution\"_\n" +
	"\x11CollectionsSearch\x12%\n" +
	"\x0ecollection_ids\x18\x01 \x03(\tR\rcollectionIds\x12\x19\n" +
	"\x05limit\x18\x02 \x01(\x05H\x00R\x05limit\x88\x01\x01B\b\n" +
	"\x06_limit\"5\n" +
	"\x0eDocumentSearch\x12\x19\n" +
	"\x05limit\x18\x02 \x01(\x05H\x00R\x05limit\x88\x01\x01B\b\n" +
	"\x06_limit\"x\n" +
	"\bFunction\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x02 \x01(\tR\vdescription\x12\x16\n" +
	"\x06strict\x18\x03 \x01(\bR\x06strict\x12\x1e\n" +
	"\n" +
	"parameters\x18\x04 \x01(\tR\n" +
	"parameters\"\xef\x01\n" +
	"\bToolCall\x12\x0e\n" +
	"\x02id\x18\x01 \x01(\tR\x02id\x12)\n" +
	"\x04type\x18\x02 \x01(\x0e2\x15.xai_api.ToolCallTypeR\x04type\x12/\n" +
	"\x06status\x18\x03 \x01(\x0e2\x17.xai_api.ToolCallStatusR\x06status\x12(\n" +
	"\rerror_message\x18\x04 \x01(\tH\x01R\ferrorMessage\x88\x01\x01\x123\n" +
	"\bfunction\x18\n" +
	" \x01(\v2\x15.xai_api.FunctionCallH\x00R\bfunctionB\x06\n" +
	"\x04toolB\x10\n" +
	"\x0e_error_message\"@\n" +
	"\fFunctionCall\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1c\n" +
	"\targuments\x18\x02 \x01(\tR\targuments\"n\n" +
	"\x0eResponseFormat\x124\n" +
	"\vformat_type\x18\x01 \x01(\x0e2\x13.xai_api.FormatTypeR\n" +
	"formatType\x12\x1b\n" +
	"\x06schema\x18\x02 \x01(\tH\x00R\x06schema\x88\x01\x01B\t\n" +
	"\a_schema\"\xc9\x02\n" +
	"\x10SearchParameters\x12'\n" +
	"\x04mode\x18\x01 \x01(\x0e2\x13.xai_api.SearchModeR\x04mode\x12)\n" +
	"\asources\x18\t \x03(\v2\x0f.xai_api.SourceR\asources\x127\n" +
	"\tfrom_date\x18\x04 \x01(\v2\x1a.google.protobuf.TimestampR\bfromDate\x123\n" +
	"\ato_date\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\x06toDate\x12)\n" +
	"\x10return_citations\x18\a \x01(\bR\x0freturnCitations\x121\n" +
	"\x12max_search_results\x18\b \x01(\x05H\x00R\x10maxSearchResults\x88\x01\x01B\x15\n" +
	"\x13_max_search_results\"\xaf\x01\n" +
	"\x06Source\x12&\n" +
	"\x03web\x18\x01 \x01(\v2\x12.xai_api.WebSourceH\x00R\x03web\x12)\n" +
	"\x04news\x18\x02 \x01(\v2\x13.xai_api.NewsSourceH\x00R\x04news\x12 \n" +
	"\x01x\x18\x03 \x01(\v2\x10.xai_api.XSourceH\x00R\x01x\x12&\n" +
	"\x03rss\x18\x04 \x01(\v2\x12.xai_api.RssSourceH\x00R\x03rssB\b\n" +
	"\x06source\"\xaf\x01\n" +
	"\tWebSource\x12+\n" +
	"\x11excluded_websites\x18\x02 \x03(\tR\x10excludedWebsites\x12)\n" +
	"\x10allowed_websites\x18\x05 \x03(\tR\x0fallowedWebsites\x12\x1d\n" +
	"\acountry\x18\x03 \x01(\tH\x00R\acountry\x88\x01\x01\x12\x1f\n" +
	"\vsafe_search\x18\x04 \x01(\bR\n" +
	"safeSearchB\n" +
	"\n" +
	"\b_country\"\x85\x01\n" +
	"\n" +
	"NewsSource\x12+\n" +
	"\x11excluded_websites\x18\x02 \x03(\tR\x10excludedWebsites\x12\x1d\n" +
	"\acountry\x18\x03 \x01(\tH\x00R\acountry\x88\x01\x01\x12\x1f\n" +
	"\vsafe_search\x18\x04 \x01(\bR\n" +
	"safeSearchB\n" +
	"\n" +
	"\b_country\"\xf9\x01\n" +
	"\aXSource\x12,\n" +
	"\x12included_x_handles\x18\a \x03(\tR\x10includedXHandles\x12,\n" +
	"\x12excluded_x_handles\x18\b \x03(\tR\x10excludedXHandles\x123\n" +
	"\x13post_favorite_count\x18\t \x01(\x05H\x00R\x11postFavoriteCount\x88\x01\x01\x12+\n" +
	"\x0fpost_view_count\x18\n" +
	" \x01(\x05H\x01R\rpostViewCount\x88\x01\x01B\x16\n" +
	"\x14_post_favorite_countB\x12\n" +
	"\x10_post_view_countJ\x04\b\x06\x10\a\"!\n" +
	"\tRssSource\x12\x14\n" +
	"\x05links\x18\x01 \x03(\tR\x05links\"\xed\x05\n" +
	"\x0fRequestSettings\x12\"\n" +
	"\n" +
	"max_tokens\x18\x01 \x01(\x05H\x00R\tmaxTokens\x88\x01\x01\x12.\n" +
	"\x13parallel_tool_calls\x18\x02 \x01(\bR\x11parallelToolCalls\x125\n" +
	"\x14previous_response_id\x18\x03 \x01(\tH\x01R\x12previousResponseId\x88\x01\x01\x12H\n" +
	"\x10reasoning_effort\x18\x04 \x01(\x0e2\x18.xai_api.ReasoningEffortH\x02R\x0freasoningEffort\x88\x01\x01\x12%\n" +
	"\vtemperature\x18\x05 \x01(\x02H\x03R\vtemperature\x88\x01\x01\x12@\n" +
	"\x0fresponse_format\x18\x06 \x01(\v2\x17.xai_api.ResponseFormatR\x0eresponseFormat\x124\n" +
	"\vtool_choice\x18\a \x01(\v2\x13.xai_api.ToolChoiceR\n" +
	"toolChoice\x12#\n" +
	"\x05tools\x18\b \x03(\v2\r.xai_api.ToolR\x05tools\x12\x18\n" +
	"\x05top_p\x18\t \x01(\x02H\x04R\x04topP\x88\x01\x01\x12\x12\n" +
	"\x04user\x18\n" +
	" \x01(\tR\x04user\x12K\n" +
	"\x11search_parameters\x18\v \x01(\v2\x19.xai_api.SearchParametersH\x05R\x10searchParameters\x88\x01\x01\x12%\n" +
	"\x0estore_messages\x18\f \x01(\bR\rstoreMessages\x122\n" +
	"\x15use_encrypted_content\x18\r \x01(\bR\x13useEncryptedContentB\r\n" +
	"\v_max_tokensB\x17\n" +
	"\x15_previous_response_idB\x13\n" +
	"\x11_reasoning_effortB\x0e\n" +
	"\f_temperatureB\b\n" +
	"\x06_top_pB\x14\n" +
	"\x12_search_parameters\"=\n" +
	"\x1aGetStoredCompletionRequest\x12\x1f\n" +
	"\vresponse_id\x18\x01 \x01(\tR\n" +
	"responseId\"@\n" +
	"\x1dDeleteStoredCompletionRequest\x12\x1f\n" +
	"\vresponse_id\x18\x01 \x01(\tR\n" +
	"responseId\"A\n" +
	"\x1eDeleteStoredCompletionResponse\x12\x1f\n" +
	"\vresponse_id\x18\x01 \x01(\tR\n" +
	"responseId\"\xba\x03\n" +
	"\vDebugOutput\x12\x1a\n" +
	"\battempts\x18\x01 \x01(\x05R\battempts\x12\x18\n" +
	"\arequest\x18\x02 \x01(\tR\arequest\x12\x16\n" +
	"\x06prompt\x18\x03 \x01(\tR\x06prompt\x12%\n" +
	"\x0eengine_request\x18\t \x01(\tR\rengineRequest\x12\x1c\n" +
	"\tresponses\x18\x04 \x03(\tR\tresponses\x12\x16\n" +
	"\x06chunks\x18\f \x03(\tR\x06chunks\x12(\n" +
	"\x10cache_read_count\x18\x05 \x01(\rR\x0ecacheReadCount\x123\n" +
	"\x16cache_read_input_bytes\x18\x06 \x01(\x04R\x13cacheReadInputBytes\x12*\n" +
	"\x11cache_write_count\x18\a \x01(\rR\x0fcacheWriteCount\x125\n" +
	"\x17cache_write_input_bytes\x18\b \x01(\x04R\x14cacheWriteInputBytes\x12\x1d\n" +
	"\n" +
	"lb_address\x18\n" +
	" \x01(\tR\tlbAddress\x12\x1f\n" +
	"\vsampler_tag\x18\v \x01(\tR\n" +
	"samplerTag*y\n" +
	"\vMessageRole\x12\x10\n" +
	"\fINVALID_ROLE\x10\x00\x12\r\n" +
	"\tROLE_USER\x10\x01\x12\x12\n" +
	"\x0eROLE_ASSISTANT\x10\x02\x12\x0f\n" +
	"\vROLE_SYSTEM\x10\x03\x12\x15\n" +
	"\rROLE_FUNCTION\x10\x04\x1a\x02\b\x01\x12\r\n" +
	"\tROLE_TOOL\x10\x05*Y\n" +
	"\x0fReasoningEffort\x12\x12\n" +
	"\x0eINVALID_EFFORT\x10\x00\x12\x0e\n" +
	"\n" +
	"EFFORT_LOW\x10\x01\x12\x11\n" +
	"\rEFFORT_MEDIUM\x10\x02\x12\x0f\n" +
	"\vEFFORT_HIGH\x10\x03*a\n" +
	"\bToolMode\x12\x15\n" +
	"\x11TOOL_MODE_INVALID\x10\x00\x12\x12\n" +
	"\x0eTOOL_MODE_AUTO\x10\x01\x12\x12\n" +
	"\x0eTOOL_MODE_NONE\x10\x02\x12\x16\n" +
	"\x12TOOL_MODE_REQUIRED\x10\x03*u\n" +
	"\n" +
	"FormatType\x12\x17\n" +
	"\x13FORMAT_TYPE_INVALID\x10\x00\x12\x14\n" +
	"\x10FORMAT_TYPE_TEXT\x10\x01\x12\x1b\n" +
	"\x17FORMAT_TYPE_JSON_OBJECT\x10\x02\x12\x1b\n" +
	"\x17FORMAT_TYPE_JSON_SCHEMA\x10\x03*\xaf\x02\n" +
	"\fToolCallType\x12\x1a\n" +
	"\x16TOOL_CALL_TYPE_INVALID\x10\x00\x12#\n" +
	"\x1fTOOL_CALL_TYPE_CLIENT_SIDE_TOOL\x10\x01\x12\"\n" +
	"\x1eTOOL_CALL_TYPE_WEB_SEARCH_TOOL\x10\x02\x12 \n" +
	"\x1cTOOL_CALL_TYPE_X_SEARCH_TOOL\x10\x03\x12&\n" +
	"\"TOOL_CALL_TYPE_CODE_EXECUTION_TOOL\x10\x04\x12*\n" +
	"&TOOL_CALL_TYPE_COLLECTIONS_SEARCH_TOOL\x10\x05\x12\x1b\n" +
	"\x17TOOL_CALL_TYPE_MCP_TOOL\x10\x06\x12'\n" +
	"#TOOL_CALL_TYPE_DOCUMENT_SEARCH_TOOL\x10\a*\x90\x01\n" +
	"\x0eToolCallStatus\x12 \n" +
	"\x1cTOOL_CALL_STATUS_IN_PROGRESS\x10\x00\x12\x1e\n" +
	"\x1aTOOL_CALL_STATUS_COMPLETED\x10\x01\x12\x1f\n" +
	"\x1bTOOL_CALL_STATUS_INCOMPLETE\x10\x02\x12\x1b\n" +
	"\x17TOOL_CALL_STATUS_FAILED\x10\x03*d\n" +
	"\n" +
	"SearchMode\x12\x17\n" +
	"\x13INVALID_SEARCH_MODE\x10\x00\x12\x13\n" +
	"\x0fOFF_SEARCH_MODE\x10\x01\x12\x12\n" +
	"\x0eON_SEARCH_MODE\x10\x02\x12\x14\n" +
	"\x10AUTO_SEARCH_MODE\x10\x032\xc4\x04\n" +
	"\x04Chat\x12U\n" +
	"\rGetCompletion\x12\x1e.xai_api.GetCompletionsRequest\x1a\".xai_api.GetChatCompletionResponse\"\x00\x12Y\n" +
	"\x12GetCompletionChunk\x12\x1e.xai_api.GetCompletionsRequest\x1a\x1f.xai_api.GetChatCompletionChunk\"\x000\x01\x12[\n" +
	"\x17StartDeferredCompletion\x12\x1e.xai_api.GetCompletionsRequest\x1a\x1e.xai_api.StartDeferredResponse\"\x00\x12^\n" +
	"\x15GetDeferredCompletion\x12\x1b.xai_api.GetDeferredRequest\x1a&.xai_api.GetDeferredCompletionResponse\"\x00\x12`\n" +
	"\x13GetStoredCompletion\x12#.xai_api.GetStoredCompletionRequest\x1a\".xai_api.GetChatCompletionResponse\"\x00\x12k\n" +
	"\x16DeleteStoredCompletion\x12&.xai_api.DeleteStoredCompletionRequest\x1a'.xai_api.DeleteStoredCompletionResponse\"\x00B\x80\x01\n" +
	"\vcom.xai_apiB\tChatProtoP\x01Z.github.com/zchee/tumix/model/xai/pb/xai/api/v1\xa2\x02\x03XXX\xaa\x02\x06XaiApi\xca\x02\x06XaiApi\xe2\x02\x12XaiApi\\GPBMetadata\xea\x02\x06XaiApib\x06proto3"

var (
	file_xai_api_v1_chat_proto_rawDescOnce sync.Once
	file_xai_api_v1_chat_proto_rawDescData []byte
)

func file_xai_api_v1_chat_proto_rawDescGZIP() []byte {
	file_xai_api_v1_chat_proto_rawDescOnce.Do(func() {
		file_xai_api_v1_chat_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_xai_api_v1_chat_proto_rawDesc), len(file_xai_api_v1_chat_proto_rawDesc)))
	})
	return file_xai_api_v1_chat_proto_rawDescData
}

var file_xai_api_v1_chat_proto_enumTypes = make([]protoimpl.EnumInfo, 7)
var file_xai_api_v1_chat_proto_msgTypes = make([]protoimpl.MessageInfo, 38)
var file_xai_api_v1_chat_proto_goTypes = []any{
	(MessageRole)(0),                       // 0: xai_api.MessageRole
	(ReasoningEffort)(0),                   // 1: xai_api.ReasoningEffort
	(ToolMode)(0),                          // 2: xai_api.ToolMode
	(FormatType)(0),                        // 3: xai_api.FormatType
	(ToolCallType)(0),                      // 4: xai_api.ToolCallType
	(ToolCallStatus)(0),                    // 5: xai_api.ToolCallStatus
	(SearchMode)(0),                        // 6: xai_api.SearchMode
	(*GetCompletionsRequest)(nil),          // 7: xai_api.GetCompletionsRequest
	(*GetChatCompletionResponse)(nil),      // 8: xai_api.GetChatCompletionResponse
	(*GetChatCompletionChunk)(nil),         // 9: xai_api.GetChatCompletionChunk
	(*GetDeferredCompletionResponse)(nil),  // 10: xai_api.GetDeferredCompletionResponse
	(*CompletionOutput)(nil),               // 11: xai_api.CompletionOutput
	(*CompletionMessage)(nil),              // 12: xai_api.CompletionMessage
	(*CompletionOutputChunk)(nil),          // 13: xai_api.CompletionOutputChunk
	(*Delta)(nil),                          // 14: xai_api.Delta
	(*LogProbs)(nil),                       // 15: xai_api.LogProbs
	(*LogProb)(nil),                        // 16: xai_api.LogProb
	(*TopLogProb)(nil),                     // 17: xai_api.TopLogProb
	(*Content)(nil),                        // 18: xai_api.Content
	(*FileContent)(nil),                    // 19: xai_api.FileContent
	(*Message)(nil),                        // 20: xai_api.Message
	(*ToolChoice)(nil),                     // 21: xai_api.ToolChoice
	(*Tool)(nil),                           // 22: xai_api.Tool
	(*MCP)(nil),                            // 23: xai_api.MCP
	(*WebSearch)(nil),                      // 24: xai_api.WebSearch
	(*XSearch)(nil),                        // 25: xai_api.XSearch
	(*CodeExecution)(nil),                  // 26: xai_api.CodeExecution
	(*CollectionsSearch)(nil),              // 27: xai_api.CollectionsSearch
	(*DocumentSearch)(nil),                 // 28: xai_api.DocumentSearch
	(*Function)(nil),                       // 29: xai_api.Function
	(*ToolCall)(nil),                       // 30: xai_api.ToolCall
	(*FunctionCall)(nil),                   // 31: xai_api.FunctionCall
	(*ResponseFormat)(nil),                 // 32: xai_api.ResponseFormat
	(*SearchParameters)(nil),               // 33: xai_api.SearchParameters
	(*Source)(nil),                         // 34: xai_api.Source
	(*WebSource)(nil),                      // 35: xai_api.WebSource
	(*NewsSource)(nil),                     // 36: xai_api.NewsSource
	(*XSource)(nil),                        // 37: xai_api.XSource
	(*RssSource)(nil),                      // 38: xai_api.RssSource
	(*RequestSettings)(nil),                // 39: xai_api.RequestSettings
	(*GetStoredCompletionRequest)(nil),     // 40: xai_api.GetStoredCompletionRequest
	(*DeleteStoredCompletionRequest)(nil),  // 41: xai_api.DeleteStoredCompletionRequest
	(*DeleteStoredCompletionResponse)(nil), // 42: xai_api.DeleteStoredCompletionResponse
	(*DebugOutput)(nil),                    // 43: xai_api.DebugOutput
	nil,                                    // 44: xai_api.MCP.ExtraHeadersEntry
	(*timestamppb.Timestamp)(nil),          // 45: google.protobuf.Timestamp
	(*SamplingUsage)(nil),                  // 46: xai_api.SamplingUsage
	(DeferredStatus)(0),                    // 47: xai_api.DeferredStatus
	(FinishReason)(0),                      // 48: xai_api.FinishReason
	(*ImageUrlContent)(nil),                // 49: xai_api.ImageUrlContent
	(*GetDeferredRequest)(nil),             // 50: xai_api.GetDeferredRequest
	(*StartDeferredResponse)(nil),          // 51: xai_api.StartDeferredResponse
}
var file_xai_api_v1_chat_proto_depIdxs = []int32{
	20, // 0: xai_api.GetCompletionsRequest.messages:type_name -> xai_api.Message
	22, // 1: xai_api.GetCompletionsRequest.tools:type_name -> xai_api.Tool
	21, // 2: xai_api.GetCompletionsRequest.tool_choice:type_name -> xai_api.ToolChoice
	32, // 3: xai_api.GetCompletionsRequest.response_format:type_name -> xai_api.ResponseFormat
	1,  // 4: xai_api.GetCompletionsRequest.reasoning_effort:type_name -> xai_api.ReasoningEffort
	33, // 5: xai_api.GetCompletionsRequest.search_parameters:type_name -> xai_api.SearchParameters
	11, // 6: xai_api.GetChatCompletionResponse.outputs:type_name -> xai_api.CompletionOutput
	45, // 7: xai_api.GetChatCompletionResponse.created:type_name -> google.protobuf.Timestamp
	46, // 8: xai_api.GetChatCompletionResponse.usage:type_name -> xai_api.SamplingUsage
	39, // 9: xai_api.GetChatCompletionResponse.settings:type_name -> xai_api.RequestSettings
	43, // 10: xai_api.GetChatCompletionResponse.debug_output:type_name -> xai_api.DebugOutput
	13, // 11: xai_api.GetChatCompletionChunk.outputs:type_name -> xai_api.CompletionOutputChunk
	45, // 12: xai_api.GetChatCompletionChunk.created:type_name -> google.protobuf.Timestamp
	46, // 13: xai_api.GetChatCompletionChunk.usage:type_name -> xai_api.SamplingUsage
	43, // 14: xai_api.GetChatCompletionChunk.debug_output:type_name -> xai_api.DebugOutput
	47, // 15: xai_api.GetDeferredCompletionResponse.status:type_name -> xai_api.DeferredStatus
	8,  // 16: xai_api.GetDeferredCompletionResponse.response:type_name -> xai_api.GetChatCompletionResponse
	48, // 17: xai_api.CompletionOutput.finish_reason:type_name -> xai_api.FinishReason
	12, // 18: xai_api.CompletionOutput.message:type_name -> xai_api.CompletionMessage
	15, // 19: xai_api.CompletionOutput.logprobs:type_name -> xai_api.LogProbs
	0,  // 20: xai_api.CompletionMessage.role:type_name -> xai_api.MessageRole
	30, // 21: xai_api.CompletionMessage.tool_calls:type_name -> xai_api.ToolCall
	14, // 22: xai_api.CompletionOutputChunk.delta:type_name -> xai_api.Delta
	15, // 23: xai_api.CompletionOutputChunk.logprobs:type_name -> xai_api.LogProbs
	48, // 24: xai_api.CompletionOutputChunk.finish_reason:type_name -> xai_api.FinishReason
	0,  // 25: xai_api.Delta.role:type_name -> xai_api.MessageRole
	30, // 26: xai_api.Delta.tool_calls:type_name -> xai_api.ToolCall
	16, // 27: xai_api.LogProbs.content:type_name -> xai_api.LogProb
	17, // 28: xai_api.LogProb.top_logprobs:type_name -> xai_api.TopLogProb
	49, // 29: xai_api.Content.image_url:type_name -> xai_api.ImageUrlContent
	19, // 30: xai_api.Content.file:type_name -> xai_api.FileContent
	18, // 31: xai_api.Message.content:type_name -> xai_api.Content
	0,  // 32: xai_api.Message.role:type_name -> xai_api.MessageRole
	30, // 33: xai_api.Message.tool_calls:type_name -> xai_api.ToolCall
	2,  // 34: xai_api.ToolChoice.mode:type_name -> xai_api.ToolMode
	29, // 35: xai_api.Tool.function:type_name -> xai_api.Function
	24, // 36: xai_api.Tool.web_search:type_name -> xai_api.WebSearch
	25, // 37: xai_api.Tool.x_search:type_name -> xai_api.XSearch
	26, // 38: xai_api.Tool.code_execution:type_name -> xai_api.CodeExecution
	27, // 39: xai_api.Tool.collections_search:type_name -> xai_api.CollectionsSearch
	23, // 40: xai_api.Tool.mcp:type_name -> xai_api.MCP
	28, // 41: xai_api.Tool.document_search:type_name -> xai_api.DocumentSearch
	44, // 42: xai_api.MCP.extra_headers:type_name -> xai_api.MCP.ExtraHeadersEntry
	45, // 43: xai_api.XSearch.from_date:type_name -> google.protobuf.Timestamp
	45, // 44: xai_api.XSearch.to_date:type_name -> google.protobuf.Timestamp
	4,  // 45: xai_api.ToolCall.type:type_name -> xai_api.ToolCallType
	5,  // 46: xai_api.ToolCall.status:type_name -> xai_api.ToolCallStatus
	31, // 47: xai_api.ToolCall.function:type_name -> xai_api.FunctionCall
	3,  // 48: xai_api.ResponseFormat.format_type:type_name -> xai_api.FormatType
	6,  // 49: xai_api.SearchParameters.mode:type_name -> xai_api.SearchMode
	34, // 50: xai_api.SearchParameters.sources:type_name -> xai_api.Source
	45, // 51: xai_api.SearchParameters.from_date:type_name -> google.protobuf.Timestamp
	45, // 52: xai_api.SearchParameters.to_date:type_name -> google.protobuf.Timestamp
	35, // 53: xai_api.Source.web:type_name -> xai_api.WebSource
	36, // 54: xai_api.Source.news:type_name -> xai_api.NewsSource
	37, // 55: xai_api.Source.x:type_name -> xai_api.XSource
	38, // 56: xai_api.Source.rss:type_name -> xai_api.RssSource
	1,  // 57: xai_api.RequestSettings.reasoning_effort:type_name -> xai_api.ReasoningEffort
	32, // 58: xai_api.RequestSettings.response_format:type_name -> xai_api.ResponseFormat
	21, // 59: xai_api.RequestSettings.tool_choice:type_name -> xai_api.ToolChoice
	22, // 60: xai_api.RequestSettings.tools:type_name -> xai_api.Tool
	33, // 61: xai_api.RequestSettings.search_parameters:type_name -> xai_api.SearchParameters
	7,  // 62: xai_api.Chat.GetCompletion:input_type -> xai_api.GetCompletionsRequest
	7,  // 63: xai_api.Chat.GetCompletionChunk:input_type -> xai_api.GetCompletionsRequest
	7,  // 64: xai_api.Chat.StartDeferredCompletion:input_type -> xai_api.GetCompletionsRequest
	50, // 65: xai_api.Chat.GetDeferredCompletion:input_type -> xai_api.GetDeferredRequest
	40, // 66: xai_api.Chat.GetStoredCompletion:input_type -> xai_api.GetStoredCompletionRequest
	41, // 67: xai_api.Chat.DeleteStoredCompletion:input_type -> xai_api.DeleteStoredCompletionRequest
	8,  // 68: xai_api.Chat.GetCompletion:output_type -> xai_api.GetChatCompletionResponse
	9,  // 69: xai_api.Chat.GetCompletionChunk:output_type -> xai_api.GetChatCompletionChunk
	51, // 70: xai_api.Chat.StartDeferredCompletion:output_type -> xai_api.StartDeferredResponse
	10, // 71: xai_api.Chat.GetDeferredCompletion:output_type -> xai_api.GetDeferredCompletionResponse
	8,  // 72: xai_api.Chat.GetStoredCompletion:output_type -> xai_api.GetChatCompletionResponse
	42, // 73: xai_api.Chat.DeleteStoredCompletion:output_type -> xai_api.DeleteStoredCompletionResponse
	68, // [68:74] is the sub-list for method output_type
	62, // [62:68] is the sub-list for method input_type
	62, // [62:62] is the sub-list for extension type_name
	62, // [62:62] is the sub-list for extension extendee
	0,  // [0:62] is the sub-list for field type_name
}

func init() { file_xai_api_v1_chat_proto_init() }
func file_xai_api_v1_chat_proto_init() {
	if File_xai_api_v1_chat_proto != nil {
		return
	}
	file_xai_api_v1_deferred_proto_init()
	file_xai_api_v1_image_proto_init()
	file_xai_api_v1_sample_proto_init()
	file_xai_api_v1_usage_proto_init()
	file_xai_api_v1_chat_proto_msgTypes[0].OneofWrappers = []any{}
	file_xai_api_v1_chat_proto_msgTypes[3].OneofWrappers = []any{}
	file_xai_api_v1_chat_proto_msgTypes[11].OneofWrappers = []any{
		(*Content_Text)(nil),
		(*Content_ImageUrl)(nil),
		(*Content_File)(nil),
	}
	file_xai_api_v1_chat_proto_msgTypes[13].OneofWrappers = []any{}
	file_xai_api_v1_chat_proto_msgTypes[14].OneofWrappers = []any{
		(*ToolChoice_Mode)(nil),
		(*ToolChoice_FunctionName)(nil),
	}
	file_xai_api_v1_chat_proto_msgTypes[15].OneofWrappers = []any{
		(*Tool_Function)(nil),
		(*Tool_WebSearch)(nil),
		(*Tool_XSearch)(nil),
		(*Tool_CodeExecution)(nil),
		(*Tool_CollectionsSearch)(nil),
		(*Tool_Mcp)(nil),
		(*Tool_DocumentSearch)(nil),
	}
	file_xai_api_v1_chat_proto_msgTypes[16].OneofWrappers = []any{}
	file_xai_api_v1_chat_proto_msgTypes[17].OneofWrappers = []any{}
	file_xai_api_v1_chat_proto_msgTypes[18].OneofWrappers = []any{}
	file_xai_api_v1_chat_proto_msgTypes[20].OneofWrappers = []any{}
	file_xai_api_v1_chat_proto_msgTypes[21].OneofWrappers = []any{}
	file_xai_api_v1_chat_proto_msgTypes[23].OneofWrappers = []any{
		(*ToolCall_Function)(nil),
	}
	file_xai_api_v1_chat_proto_msgTypes[25].OneofWrappers = []any{}
	file_xai_api_v1_chat_proto_msgTypes[26].OneofWrappers = []any{}
	file_xai_api_v1_chat_proto_msgTypes[27].OneofWrappers = []any{
		(*Source_Web)(nil),
		(*Source_News)(nil),
		(*Source_X)(nil),
		(*Source_Rss)(nil),
	}
	file_xai_api_v1_chat_proto_msgTypes[28].OneofWrappers = []any{}
	file_xai_api_v1_chat_proto_msgTypes[29].OneofWrappers = []any{}
	file_xai_api_v1_chat_proto_msgTypes[30].OneofWrappers = []any{}
	file_xai_api_v1_chat_proto_msgTypes[32].OneofWrappers = []any{}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_xai_api_v1_chat_proto_rawDesc), len(file_xai_api_v1_chat_proto_rawDesc)),
			NumEnums:      7,
			NumMessages:   38,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_xai_api_v1_chat_proto_goTypes,
		DependencyIndexes: file_xai_api_v1_chat_proto_depIdxs,
		EnumInfos:         file_xai_api_v1_chat_proto_enumTypes,
		MessageInfos:      file_xai_api_v1_chat_proto_msgTypes,
	}.Build()
	File_xai_api_v1_chat_proto = out.File
	file_xai_api_v1_chat_proto_goTypes = nil
	file_xai_api_v1_chat_proto_depIdxs = nil
}
